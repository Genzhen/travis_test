---
title: JavaScript函数式编程
date: 2018-08-23 23:35:37
tags: [JavaScript, 函数式编程]
categories: note
---
** {{ title }}：** <Excerpt in index | 首页摘要>
<!-- more -->
<The rest of contents | 余下全文>

<div class="editor-area" id="noteIFrameContent"><div style="white-space: pre-wrap;" yne-bulb-block="paragraph"><br></div><div yne-bulb-type="catalogue-wrap"><div style="white-space: pre-wrap;" yne-bulb-block="catalogue"><a href="#1663-1534938145402"></a></div><blockquote style="margin:0 0 0 40px;border:none;padding:0px;"><div style="white-space: pre-wrap;" yne-bulb-block="catalogue"><a href="#2375-1534938105605"></a></div></blockquote><blockquote style="margin:0 0 0 40px;border:none;padding:0px;"><div style="white-space: pre-wrap;" yne-bulb-block="catalogue"><a href="#5070-1534938121849"></a></div></blockquote></div><div style="white-space: pre-wrap;" id="1663-1534938145402" yne-bulb-block="heading"><span style="font-size:28px;font-weight:bold;">（一）第一周JavaScript语言新发展【直播课】</span></div><div style="white-space: pre-wrap;" id="2375-1534938105605" yne-bulb-block="heading"><span style="font-size:20px;font-weight:bold;">一、开学典礼</span></div><div style="white-space: pre-wrap;" id="5070-1534938121849" yne-bulb-block="heading"><span style="font-size:20px;font-weight:bold;">二、JavaScript函数式编程</span></div><div style="white-space: pre-wrap;" id="4315-1534938138028" yne-bulb-block="heading"><span style="font-weight:bold;">1.函数式编程思维</span></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">范畴论  Category Theory</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">1. 函数式编程是范畴论的数学分支，是一门复杂的数学，人为世界上所有的概念都可以抽象出一个范畴	</li><li style="list-style-position:inside;">2.彼此之间存在某种关系概念、事物、对象等，都构成范畴。任何事物只要找出他们之间的关系，就能定义</li><li style="list-style-position:inside;">3.箭头表示范畴成员之间的关系，正式的名称叫做“态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的“变形”（transform）。通过态射，一个成员可以变形成另一个成员</li><li style="list-style-position:inside;">注：所有成员是一个集合，变形关系是函数</li></ul><li style="list-style-position:inside;">函数式编程基础理论</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">1.函数式编程(Function Programming)其实相对于计算机的历史而言，是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于λ（lambda x=&gt;x*2）演算，而λ演算并非设计于在计算机上执行，它是在20世纪30年代引入的一套用于研究函数定义、函数应用和递归的系统。</li><li style="list-style-position:inside;">2.函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用</li><li style="list-style-position:inside;">3.JavaScript是披着C外衣的lisp</li><li style="list-style-position:inside;">4.真正的火热是随着React的高阶函数而逐步升温</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph"><br></div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">a.函数是一等公民。所谓“第一等公民”（first class）,指的是函数与其它数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li><li style="list-style-position:inside;">b.不可变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了，在函数式编程中变量仅仅代表了某个表达式。这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。</li><li style="list-style-position:inside;">c.map&amp;reduce它们是最常用的函数式编程的方法。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph"><br></div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">函数是“第一等公民”</li><li style="list-style-position:inside;">只用表达式，不用语句</li><li style="list-style-position:inside;">没有副作用</li><li style="list-style-position:inside;">不修改状态</li><li style="list-style-position:inside;">引用透明（函数运行只靠参数）</li></ul></ul><div style="white-space: pre-wrap;" id="2054-1534939509642" yne-bulb-block="heading"><span style="font-weight:bold;">2.函数式编程常用核心概念</span></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">纯函数</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var s = [1,2,3,4];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.slice(0,3);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.slice(0,3) </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.splice(0,3);//splice会改变原数组</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.splice(0,3);</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">优点：纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                import _ from 'lodash';</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var sin = _.memorize(x=&gt;{Math.sin(x)});</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //第一次计算的时候会稍微慢一点</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var a sin(7);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //第二次有了缓存，速度极快</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var b = sin(7); </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><ul style="list-style-type:square"><li style="list-style-position:inside;">在不纯的版本中，checkAge不仅取决于age还有外部依赖的便令min，纯的checkAge把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //不纯的</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var min = 18;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var checkAge = age=&gt;age&gt;min;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //纯的</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var checkAge = age=&gt;age&gt;18; </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><ul style="list-style-type:square"><li style="list-style-position:inside;">纯度和幂等性</li><ul style="list-style-type:disc;"><li style="list-style-position:inside;">幂等性是指执行无数次后还具有相同的效果，同一个参数运行一次应该与连续运行两次的结果一致。幂等性在函数编程中与纯度相关，但又不一致。</li></ul></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                Math.abs(Math.abs(-42));//42</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">函数的柯里化</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</li><li style="list-style-position:inside;">示例：柯里化上边的checkAge</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var checkAge = min=&gt;(age=&gt;age&gt;min);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            vae checkAge18 = checkAge(18);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            checkAge(20);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            ----------函数柯里化code-------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //函数柯里化之前</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function add(x,y){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return x+y;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            add(1,2);//3</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            <br></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //柯里化之后</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function addX(y){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return function (x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    return x+y;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            addX(2)(1);//3</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的‘缓存’，是一种非常高效的编写函数的方法</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            import {curry} from 'lodash';</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var match = curry((reg,str)=&gt;str.match(reg));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var filter = curry((f,arr)=&gt;arr.filter(f));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var haveSpace = match(/\s+/g);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            haveSpace("ffffff");</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            haveSpace('a b');</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            filter(haveSpace,['adsf','adfs adfs']);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            filter(haveSpace)(['adsf','adfs adfs']);</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">函数组合</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">纯函数以及如何把它写出的洋葱代码h(g(f(x)))柯里化，为了解决函数嵌套的问题，需要用到函数组合。</li><li style="list-style-position:inside;"> 代码示例</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            const compose = (f,g)=&gt;(x=&gt;f(g(x)));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var first = arr=&gt;arr[0];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var reverse = arr =&gt;arr.reverse();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var last = compose(first,reverse);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            last([1,2,3,4,5]);</div><div yne-bulb-block="image"><img style="width: 431px; cursor: pointer;" alt="" src="images/replace-img.png" data-media-type="image" data-original="https://note.youdao.com/yws/public/resource/aec0c2734c30aebc54626244a94fcd9e/xmlnote/9F077C5BF0394B8A833026D43701877F/21658"></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">Point Free</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。</li><li style="list-style-position:inside;">这个函数中，使用了str作为中间变量，但这个中间变量除了让代码变得长了一点以外是毫无意义的。</li><ul style="list-style-type:square"><li style="list-style-position:inside;">const  f=str=&gt;str.toUpperCase().split('');</li></ul><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var toUpperCase = word=&gt;word.toUpperCase();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var split = x=&gt;(str=&gt;str.split(x));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var  f = compose(split('',toUpperCase));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            f('ad adsf ads');</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">声明式代码与命令式代码</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">命令式代码的意思就是，我们通过编写一条又一条指令去让计算机执行一些动作，这其中一半都会涉及到很多繁杂的细节。而声明式代码就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步步的指示。</li><li style="list-style-position:inside;">代码示例：</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //命令式</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            let ceo = [];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            for(var i = 0;i &lt; compain.length;i++){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                ceo.push(compain[i].ceo);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //声明式</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            let ceo = compain.map(c=&gt;c.ceo);</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的。专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。</li><li style="list-style-position:inside;">相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。</li></ul></ul><li style="list-style-position:inside;">惰性求值、惰性函数、惰性链</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于其它外部的状态，因此必须顺序执行。</li><li style="list-style-position:inside;">惰性求值示例</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function ajax(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                if(XMLHttpRequest){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    ajax = function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        return new XMLHttpRequest();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                }else{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    ajax = function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        return new ActiceXObject('Microsoft.XMLHTTP');</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">惰性链</li><ul style="list-style-type:square"><li style="list-style-position:inside;">new LazyChain([1,2,3]).add().xx();后边可以点点，但是和链式调用不一样，简单说就是，链式调用，每一步都会执行有返回值，而惰性链每一步没有返回值，而是等到最后一步才返回具体的值</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">3.函数式编程深入</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    高阶函数</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //命令式</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var add = function(a,b){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return a+ b;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function math(fn,arr){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return fn(arr[0],arr[1]);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            math(add[7,2]);//3</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    它是一等公民</li><li style="list-style-position:inside;">    它是一个函数作为参数</li><li style="list-style-position:inside;">    以一个函数作为返回结果</li></ul><li style="list-style-position:inside;">    尾调用优化</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。函数调用自身，称为递归。如果尾调用自身，就是尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //不是尾递归无法优化</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function fn(n){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            if(n===1) return 1;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return n*fn(n-1);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function fn(n,total){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            if(n===1) return total;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return fn(n-1,n*total);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //es6强制使用尾递归</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    普通递归</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    普通递归时，内容需要记录调用的堆栈所处的深度和位置信息，在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。cpu计算和内存会消耗很多，而且当深度过深时，会出现堆栈溢出。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function sum(n){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                n===1&amp;&amp;return 1;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return n+sum(n-1);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(5)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+sum(4))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+sum(3)))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+sum(2))))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+(2+sum(1)))))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+(2+1))))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+3)))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+6))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+10)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            15</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    尾递归</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    整个计算过程是线性的，调用一次sum(x,total)后，相关数据信息跟随进入下一个栈，不再放在堆栈上保存。当计算完值后，直接返回到最上层的sum(5,0).这能有效的防止堆栈溢出。</li><li style="list-style-position:inside;">    在ECMAScript6，我们将迎来尾递归优化，通过尾递归优化，JavaScript代码在解释成机器码的时候，将会向while看齐，也就是说，同时拥有数学表达能力和while的效能。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function sum(x,total){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                n===1&amp;&amp;return x + total;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return sum(x-1,x+total);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(5,0)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(4,5)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(3,9)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(2,12)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(1,14)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            15</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    闭包</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    如下例子，虽然外层的makePowerFn函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不释放，因此power依旧可以被powerFn函数访问，这样就形成了闭包。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function makePowerFn(power){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function powerFn(base){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return Math.pow(base,power);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return powerFn;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var square = makePowerFn(2);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        square(3);//9</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    范畴与容器</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.我们可以把‘范畴’想像成一个容器，里面包含两样东西。值、值得变形关系，也就是函数。</li><li style="list-style-position:inside;">    2.范畴论使用函数，表达范畴之间的关系</li><li style="list-style-position:inside;">    3.伴随着范畴论的发展，就发展出一整套函数运算的方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的函数式编程。</li><li style="list-style-position:inside;">    4.本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其它的事情，否则就无法满足函数运算法则了。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">     </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.函数不仅可以用于同一个范畴之中值得转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）</li><li style="list-style-position:inside;">    2.函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变成另一个容器。</li></ul></ul><div yne-bulb-block="image"><img alt="" src="images/replace-img.png" data-media-type="image" data-original="https://note.youdao.com/yws/public/resource/aec0c2734c30aebc54626244a94fcd9e/xmlnote/384E272960584913ADB08795345A955F/21794" style="cursor: pointer;"></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    容器、Functor</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    $(‘’)返回的对象并不是一个原生的dom对象，而是对于原生对象的一种封装，这在某种意义上就是一个容器（但它并不函数式）</li><li style="list-style-position:inside;">    Functor(函子)是遵守一些特定规则的容器类型</li><li style="list-style-position:inside;">    任何具有map方法的数据结构，都可以当做函子的实现。</li><li style="list-style-position:inside;">    Functor是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由选择何时何地地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。</li></ul><li style="list-style-position:inside;">    函子的代码实现</li></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  Container  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.__value =  x;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //函数式编程一般约定，函子有一个of方法,用来实现new操作</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Container.of =  x=&gt;new Container(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //一般约定，函子的标志就是容器具有map方法。该方法将容器里面的额每一个值，映射到另一个容器。</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Container.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return Container.of(f(this.__value));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Container.of(3)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            .map(x=&gt;x+1)          //=&gt;Container(4)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            .map(x=&gt;'result  is'+  x);      //=&gt;Container('result is 4')</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        --------------es6写法----------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class  Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            constructor(val){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                this.val =  val;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return new Functor(f(this.val))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //写法一，这样写在生成新函子的时候，用了new命令。不符合函数式编程，因为new命令式面向对象的标志。</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //函数式编程一般约定，函子有一个of方法，用来生成新的容器。</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        (new Functor(2)).map(function  (two){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return two +2;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        });</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Functor (4);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //写法二，修改</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Functor.of =  function(val){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Functor(val);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        };</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Functor.of(2).map(function(two){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return two +  2;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Functor(4)</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    上面代码中，Functor是一个函子，它的map方法接受函数作为参数，然后返回一个新的函子，里面包含的值是被f处理过的f(this.val)。一般约定，函子的标志是拥有map方法。该方法将容器里面的每一个值，映射到另一个容器。</li><li style="list-style-position:inside;">    上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值得容器----函子。函子本身具有对外接口（map方法），各种函数运算就是运算符，通过接口接入容器，引发容器里面的变形。因此，学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。</li></ul><li style="list-style-position:inside;">    Maybe函子</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //当传入空值的时候会报错，</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Functor.of(null).map(function(s){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return  s.toUpperCase();//Cannot read property 'toUpperCase' of null</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ------------------------------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //通过Maybe函子进行处理如下,先对值进行一次判断</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class  Maybe  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.val?Maybe.of(f(this.val)):Maybe.of(null);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.of(null).map(function(s){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return s.toUpperCase();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Maybe(null)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        -------------------------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Maybe函子</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  Maybe  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.__value =  x;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.of  =  function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Maybe(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return this.isNothing()?Maybe.of(null):Maybe.of(f(this.__value));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.prototype.isNothing =  function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return (this.__value ===  null||  this.__value ===  undefined);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //新的容器我们称之为Maybe(原型来自Haskell)</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    注：Haskell是函数式（一切通过函数调用来完成）、静态、隐式类型（类型由编译器检测，类型声明不是必须的）、惰性（除非必要，否则什么也不做）的语言。</li></ul><li style="list-style-position:inside;">    错误处理、Either</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.我们的容器能做的事情太少了，try/catch/throw并不是‘纯’的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。</li><li style="list-style-position:inside;">    2.Promise是可以调用catch来集中处理错误的</li><li style="list-style-position:inside;">    3.事实上，Either并不只是用来处理错误的，它表示了逻辑或，范畴学里边的coproducts</li><li style="list-style-position:inside;">    条件运算符if...else是最常见的运算之一，函数式编程里面，使用either函子表达。Either函子内部有两个值：左值（left）和右值（right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //代替try...catch</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class Either  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            constructor(left,right){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                this.left =  left;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                this.right =  right;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.right?Either.of(this.left,f(this.right)):Either.of(f(this.left),this.right);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of =  function(left,right){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Either(left,right);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var addOne =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return x+1;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of(5,6).map(addOne);//Either(5,7)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of(1,null).map(addOne);//Either(2,null)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of({address:'xxx'},currentUser.address).map(updatefield);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ----------------------------------------------------------------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  Left  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.__value =  x;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var Right  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            thsi.__value =  x;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Left.of  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Left(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Right.of =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Right(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Left.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return this;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Right.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return Right.of(f(this.__value));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    Left和Right唯一区别就在于map方法的实现，Right.map的行为和我们之前提到的map函数一样。但是Left.map就很不同了：它不会对容器做任何事情，只是简单的把这个容器拿进来又扔出去。这个特性意味着，Left可以用来传递一个错误消息。</li><li style="list-style-position:inside;">    示例：</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var   getAge =  user=&gt;user.age?Right.of(user.age):Left.of("ERROR");</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        getAge({name:'wang',age:'21'}).map(age=&gt;'age is'+  age);//Right('age is 21');</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        getAge({name:'wang'}).map(age=&gt;'age is'+  age);//Left('ERROR')，因为age不存在执行Left</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //left可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层又有一层的try/catch</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    AP</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    AP因子</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    1.函数里面包含的值，完全可能是函数。我们可以想象这样一个情况，一个函子的值是数值，另一个函子的值是函数。</li></ul><li style="list-style-position:inside;">    AP函子</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class  Ap  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            ap(F){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return Ap.of(this.val(F.val));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Ap.of(addTwo).ap(Function.of(2));</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    IO</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.真正的程序总要去接触肮脏的世界</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function  readLocalStorage(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return window.localStorage;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    2.IO跟前面那几个Functor不同的地方在于，它的__value是一个函数。它把不纯的操作（比如IO、网络请求、dom）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO包含的是被包裹的操作返回值。</li><li style="list-style-position:inside;">    3.IO其实也是惰性求值</li><li style="list-style-position:inside;">    4.IO负责解决调用链积累的很多不纯的操作，带来的复杂性和不可维护性。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        import  _from 'lodash';</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var compose =  _.flowRight;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var IO  =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.__value =  f;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        IO.of  =  x =&gt;new IO(_=&gt;x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        IO.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new IO (compose(f,this.__value))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        -------------------------------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        import   _from 'lodash';</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var compose =  _.flowRight;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class IO  extends Monad{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return IO.of(compose(f,this.__value))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        -----------IO函子-----------------------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  fs =  require('fs');</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var rea的File  =  function(filename){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new IO(function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return fs.readFileSync(filename,'utf-8');</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        readFile('./user.txt')</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .flatMap(tail)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .flatMap(print)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //等同于</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        readFile('./user.txt')</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .chain(tail)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .chain(prinit)</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    小结</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    我们先后用到了Maybe、Either、IO这三种强大的Functor，在链式调用、惰性求值、错误捕获、输入输出中都发挥着巨大的作用，事实上Functor远不止这三种。</li><li style="list-style-position:inside;">    1.如何处理嵌套的Functor呢？（Maybe(IO(42))）</li><li style="list-style-position:inside;">    2.如何处理一个由非纯的或异步的操作序列呢？</li></ul><li style="list-style-position:inside;">    Monad</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</li><li style="list-style-position:inside;">    2.Promise就是一种Monad</li><li style="list-style-position:inside;">    3.Monad让我们避开了嵌套地狱，可以轻松的进行深度嵌套的函数式编程，比如IO和其它异步任务。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.of(Maybe.of({name:'wang',number:12})) ;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class Monad  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            join(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.val;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            flatMap(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.map(f).join();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    Monad函子的作用是，总是返回一个单层的函子。它有一个flatMap的方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。如果函数返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，join方法保证了flatMap方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">3.流行的几大函数式编程库</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    RxJS(学习api)</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    RxJS从诞生以来一直都不温不火，但它函数响应式编程（Function Reactive  programming，FRP）的理念非常先进，虽然或许对于大部分应用环境来说，外部输入事件并不是太频繁，并不需要引入一个如此庞大的FRP体系，但我们也可以了解一下它有哪些优秀的特性。</li><li style="list-style-position:inside;">    在RxJS中，所有的外部输入（用户输入、网络请求等等）都被视作一种事件流</li><li style="list-style-position:inside;">    用户点击了按钮--&gt;网络请求成功-&gt;用户输入键盘-&gt;某个定时事件发生-&gt;这种事件流特别适合处理游戏，如下</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var  clicks =  Rx.Observable</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                .fromEvent(document,'click')</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                .bufferCount(2)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                .subscribe(x=&gt;console.log(x));//打印出前两次点击事件 </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    响应式编程是继承自函数式编程，声明式的，不可变的，没有副作用的是函数式编程的三大护法。其中不可变武功最深。一直使用面向对象编程的我们，习惯了使用变量存储和追踪程序的状态。RxJS从函数式编程范式中借鉴了很多东西，比如链式调用，惰性求值等。</li><li style="list-style-position:inside;">    在函数中与函数作用域之外的一切事物有交互就产生了副作用。比如读写文件，在控制台打印语句，修改页面元素css等。在RxJS中，把副作用问题推给了订阅者来解决。</li></ul><li style="list-style-position:inside;">    cycleJS</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    cyclejs是一个rxjs的框架，它是一个彻彻底底的FRP理念的框架和react一样支持virtula dom，jsx语法，但现在似乎没有看到大型的应用经验。</li><li style="list-style-position:inside;">    本质上讲，它就是在rxjs的基础上加了对virtual dom、容器组件的支持，比如下面就是一个简单的开关按钮</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function  main(sources){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                const sinks =  {</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    DOM:sources.DOM.select('input').events('click')</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        .map(ev=&gt;ev.target.checked)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        .startWidth(false)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        .map(toggled=&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;div&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;input type="check"  /&gt;toggle me</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;p&gt;{toggled?'ON':'off'}&lt;/p&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;/div&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        )</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                };</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return sinks;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            const drivers =  {</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                DOM:makeDOMDrive("#app");</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            run(main,drives);</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    LodashJS、lazy（惰性求值）</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    lodash是一个具有一致接口、模块化、高性能等特性的javascript工具库，是udnerscorejs的fork，其最初目标也是“一致的浏览器行为，并改善性能”。</li><li style="list-style-position:inside;">    lodash采用延迟计算，意味着我们的链式方法在显示或者隐式的value()调用之前是不会执行的，因此lodash可以进行shortcut（捷径），fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。</li><li style="list-style-position:inside;">    就如同jquery在全部函数前加全局的$一样，lodash使用全局的_来提供对工具的快速访问。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  abc =  function(a,b,c){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return [a,b,c];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var curried =  _.curry(abc);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        curried(1)(2)(3);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ------------------------------</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function square(n){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return n*n;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var addSquare =  _.flowRight(square,_.add);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        addSquare(1,2);//9</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    underscoreJS</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    underscorejs是一个javaScript工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何javaScript内置对象。他解决了这个问题：‘如果我们面对一个空白的html页面，并希望立即开始工作，我们需要什么？’它弥补了jquery没有实现功能，同时又是backbone必不可少的部分。</li><li style="list-style-position:inside;">    undescore提供了100多个函数，包括常用的：map,filter,invoke,当然还有更多专业的辅助函数，如：函数绑定、javaScript模板功能、创建快速索引、强类型相等测试等等。</li></ul><li style="list-style-position:inside;">    ramdajs</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    ramda是一个非常优秀的额sj工具库，跟同类比更函数式，主要体现在以下几个原则</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    1.ramda里面的提供的函数全部都是curry的，意味着函数没有默认参数可选参数从而减轻认知函数的难度。</li><li style="list-style-position:inside;">    2.radma推崇pointfree简单的说是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。</li><li style="list-style-position:inside;">    3.ramda有个非常好用的参数占位符R._大大减轻了函数在pointfree过程中参数位置的问题。</li><li style="list-style-position:inside;">    相比undescore/lodash感觉要干净很多</li></ul></ul></ul><div style="display:table; white-space: pre-wrap;" id="4371-1534947459296" yne-bulb-block="todo"><div style="border: 1px solid rgb(187, 187, 187); width: 1em; height: 1em; line-height: 1; position: relative; display:inline-flex;"></div><div style="display: table-cell; word-break: break-word; padding-left: 8px; width: 100%;">任务看下rxjs官方的api，把underscorejs（有点不是纯粹的函数式编程，有点老了，不过代码非常有学习的意义，学函数式编程的思想，js编程的技巧）的源码看一下 </div></div><div style="display:table; white-space: pre-wrap;" id="8179-1534947370178" yne-bulb-block="todo"><div style="border: 1px solid rgb(187, 187, 187); width: 1em; height: 1em; line-height: 1; position: relative; display:inline-flex;"></div><div style="display: table-cell; word-break: break-word; padding-left: 8px; width: 100%;">lodashjs不推荐读源码，比较复杂，学lodashjs，</div></div><div style="white-space: pre-wrap;" id="8762-1534939530883" yne-bulb-block="heading"><span style="font-weight:bold;">4.函数式编程的实际应用场景</span></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">易调试、热部署、并发</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">1.函数式编程中的每个符号都是const的，于是没有什么函数会有副作用。谁也不能在运行时候修改任何东西，也没有函数可以修改再它的作用域之外修改什么值给其它函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而且影响其返回值的唯一因素就是参数。</li><li style="list-style-position:inside;">2.函数式编程不需要考虑死锁（deadlock），因为它不修改变量，所以根本不存在锁线程问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心的把工作分摊到多个线程，部署‘并发编程’（concurrency）</li><li style="list-style-position:inside;">3.函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">5.单元测试</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    严格函数式编程的每一个符号都是对直接量或者表达式结果的引用，没有函数产生副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其它函数使用（如类成员，或全局变量）。这意味着函数求值的结果只是返回值，而唯一影响其返回值的就是函数的参数。</li><li style="list-style-position:inside;">    这是单元测试者的梦中仙境（wet  dream）。对被测试程序中的每个函数你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在java或c++中只检查函数的返回值还不够----我们还必须验证这个函数可能修改了的外部状态。</li></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">6.总结与补充</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    函数式编程不应该被视为灵丹妙药。相反，它应该被视为我们现有工具箱的一个很自然的补充---它带来了更高的可组合性，灵活性以及容错性。现在的javascript库已经开始尝试拥抱函数式编程的概念以获取这些优势。redux作为一种flux的变种实现，核心理念也是状态机的函数式编程。</li><li style="list-style-position:inside;">    函数对于外部状态的依赖是造成系统复杂性大大提高的主要原因</li><li style="list-style-position:inside;">    要让函数尽可能的纯净</li><li style="list-style-position:inside;">    我们可能没有机会在生成环境中自己去实现这样的玩具级Functor，但通过了解它们的特性会让你产生对于函数式编程的意识。</li><li style="list-style-position:inside;">    软件工程上讲，‘没有银弹’，函数式编程同样也不是万能的，它与烂大街的oop一样，只是一种编程范式而已。很多实际应用中是很难用函数式去表达的，选择oop亦或是其它编程式或许更简单。但我们要注意到函数式编程的核心理念，如果说oop降低复杂度是靠良好的额封装、继承、多态以及接口定义的话，那么函数式编程就是通过纯函数以及他们的组合、柯里化、Functor等技术来降低系统复杂度，而react，rxjs，cyclejs正式这种理念的代言。让门一起拥抱函数式编程，打开程序的大门。</li></ul></div>
