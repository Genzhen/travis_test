<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王根镇的博客</title>
  
  <subtitle>学习使用</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://WangGenzhen.github.io/"/>
  <updated>2018-08-23T15:47:27.156Z</updated>
  <id>http://WangGenzhen.github.io/</id>
  
  <author>
    <name>王根镇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript函数式编程</title>
    <link href="http://WangGenzhen.github.io/2018/08/23/JavaScript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://WangGenzhen.github.io/2018/08/23/JavaScript函数式编程/</id>
    <published>2018-08-23T15:35:37.000Z</published>
    <updated>2018-08-23T15:47:27.156Z</updated>
    
    <content type="html"><![CDATA[<p><strong> JavaScript函数式编程：</strong> <excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><div class="editor-area" id="noteIFrameContent"><div style="white-space: pre-wrap;" yne-bulb-block="paragraph"><br></div><div yne-bulb-type="catalogue-wrap"><div style="white-space: pre-wrap;" yne-bulb-block="catalogue"><a href="#1663-1534938145402"></a></div><blockquote style="margin:0 0 0 40px;border:none;padding:0px;"><div style="white-space: pre-wrap;" yne-bulb-block="catalogue"><a href="#2375-1534938105605"></a></div></blockquote><blockquote style="margin:0 0 0 40px;border:none;padding:0px;"><div style="white-space: pre-wrap;" yne-bulb-block="catalogue"><a href="#5070-1534938121849"></a></div></blockquote></div><div style="white-space: pre-wrap;" id="1663-1534938145402" yne-bulb-block="heading"><span style="font-size:28px;font-weight:bold;">（一）第一周JavaScript语言新发展【直播课】</span></div><div style="white-space: pre-wrap;" id="2375-1534938105605" yne-bulb-block="heading"><span style="font-size:20px;font-weight:bold;">一、开学典礼</span></div><div style="white-space: pre-wrap;" id="5070-1534938121849" yne-bulb-block="heading"><span style="font-size:20px;font-weight:bold;">二、JavaScript函数式编程</span></div><div style="white-space: pre-wrap;" id="4315-1534938138028" yne-bulb-block="heading"><span style="font-weight:bold;">1.函数式编程思维</span></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">范畴论  Category Theory</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">1. 函数式编程是范畴论的数学分支，是一门复杂的数学，人为世界上所有的概念都可以抽象出一个范畴    </li><li style="list-style-position:inside;">2.彼此之间存在某种关系概念、事物、对象等，都构成范畴。任何事物只要找出他们之间的关系，就能定义</li><li style="list-style-position:inside;">3.箭头表示范畴成员之间的关系，正式的名称叫做“态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的“变形”（transform）。通过态射，一个成员可以变形成另一个成员</li><li style="list-style-position:inside;">注：所有成员是一个集合，变形关系是函数</li></ul><li style="list-style-position:inside;">函数式编程基础理论</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">1.函数式编程(Function Programming)其实相对于计算机的历史而言，是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于λ（lambda x=&gt;x<em>2）演算，而λ演算并非设计于在计算机上执行，它是在20世纪30年代引入的一套用于研究函数定义、函数应用和递归的系统。</em></li><li style="list-style-position:inside;">2.函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用</li><li style="list-style-position:inside;">3.JavaScript是披着C外衣的lisp</li><li style="list-style-position:inside;">4.真正的火热是随着React的高阶函数而逐步升温</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph"><br></div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">a.函数是一等公民。所谓“第一等公民”（first class）,指的是函数与其它数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li><li style="list-style-position:inside;">b.不可变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了，在函数式编程中变量仅仅代表了某个表达式。这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。</li><li style="list-style-position:inside;">c.map&amp;reduce它们是最常用的函数式编程的方法。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph"><br></div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">函数是“第一等公民”</li><li style="list-style-position:inside;">只用表达式，不用语句</li><li style="list-style-position:inside;">没有副作用</li><li style="list-style-position:inside;">不修改状态</li><li style="list-style-position:inside;">引用透明（函数运行只靠参数）</li></ul></ul><div style="white-space: pre-wrap;" id="2054-1534939509642" yne-bulb-block="heading"><span style="font-weight:bold;">2.函数式编程常用核心概念</span></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">纯函数</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var s = [1,2,3,4];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.slice(0,3);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.slice(0,3) </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.splice(0,3);//splice会改变原数组</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            s.splice(0,3);</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">优点：纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                import _ from ‘lodash’;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var sin = _.memorize(x=&gt;{Math.sin(x)});</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //第一次计算的时候会稍微慢一点</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var a sin(7);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //第二次有了缓存，速度极快</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var b = sin(7); </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><ul style="list-style-type:square"><li style="list-style-position:inside;">在不纯的版本中，checkAge不仅取决于age还有外部依赖的便令min，纯的checkAge把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //不纯的</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var min = 18;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var checkAge = age=&gt;age&gt;min;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                //纯的</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                var checkAge = age=&gt;age&gt;18; </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><ul style="list-style-type:square"><li style="list-style-position:inside;">纯度和幂等性</li><ul style="list-style-type:disc;"><li style="list-style-position:inside;">幂等性是指执行无数次后还具有相同的效果，同一个参数运行一次应该与连续运行两次的结果一致。幂等性在函数编程中与纯度相关，但又不一致。</li></ul></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                Math.abs(Math.abs(-42));//42</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">函数的柯里化</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</li><li style="list-style-position:inside;">示例：柯里化上边的checkAge</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var checkAge = min=&gt;(age=&gt;age&gt;min);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            vae checkAge18 = checkAge(18);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            checkAge(20);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            ———-函数柯里化code————-</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //函数柯里化之前</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function add(x,y){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return x+y;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            add(1,2);//3</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            <br></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //柯里化之后</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function addX(y){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return function (x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    return x+y;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            addX(2)(1);//3</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的‘缓存’，是一种非常高效的编写函数的方法</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            import {curry} from ‘lodash’;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var match = curry((reg,str)=&gt;str.match(reg));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var filter = curry((f,arr)=&gt;arr.filter(f));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var haveSpace = match(/\s+/g);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            haveSpace(“ffffff”);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            haveSpace(‘a b’);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            filter(haveSpace,[‘adsf’,’adfs adfs’]);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            filter(haveSpace)([‘adsf’,’adfs adfs’]);</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">函数组合</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">纯函数以及如何把它写出的洋葱代码h(g(f(x)))柯里化，为了解决函数嵌套的问题，需要用到函数组合。</li><li style="list-style-position:inside;"> 代码示例</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            const compose = (f,g)=&gt;(x=&gt;f(g(x)));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var first = arr=&gt;arr[0];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var reverse = arr =&gt;arr.reverse();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var last = compose(first,reverse);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            last([1,2,3,4,5]);</div><div yne-bulb-block="image"><img style="width: 431px; cursor: pointer;" alt="" src="images/replace-img.png" data-media-type="image" data-original="https://note.youdao.com/yws/public/resource/aec0c2734c30aebc54626244a94fcd9e/xmlnote/9F077C5BF0394B8A833026D43701877F/21658"></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">Point Free</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。</li><li style="list-style-position:inside;">这个函数中，使用了str作为中间变量，但这个中间变量除了让代码变得长了一点以外是毫无意义的。</li><ul style="list-style-type:square"><li style="list-style-position:inside;">const  f=str=&gt;str.toUpperCase().split(‘’);</li></ul><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var toUpperCase = word=&gt;word.toUpperCase();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var split = x=&gt;(str=&gt;str.split(x));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var  f = compose(split(‘’,toUpperCase));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            f(‘ad adsf ads’);</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">声明式代码与命令式代码</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">命令式代码的意思就是，我们通过编写一条又一条指令去让计算机执行一些动作，这其中一半都会涉及到很多繁杂的细节。而声明式代码就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步步的指示。</li><li style="list-style-position:inside;">代码示例：</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //命令式</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            let ceo = [];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            for(var i = 0;i &lt; compain.length;i++){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                ceo.push(compain[i].ceo);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //声明式</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            let ceo = compain.map(c=&gt;c.ceo);</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">优缺点</li><ul style="list-style-type:square"><li style="list-style-position:inside;">函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的。专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。</li><li style="list-style-position:inside;">相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。</li></ul></ul><li style="list-style-position:inside;">惰性求值、惰性函数、惰性链</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于其它外部的状态，因此必须顺序执行。</li><li style="list-style-position:inside;">惰性求值示例</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function ajax(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                if(XMLHttpRequest){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    ajax = function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        return new XMLHttpRequest();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                }else{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    ajax = function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        return new ActiceXObject(‘Microsoft.XMLHTTP’);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">惰性链</li><ul style="list-style-type:square"><li style="list-style-position:inside;">new LazyChain([1,2,3]).add().xx();后边可以点点，但是和链式调用不一样，简单说就是，链式调用，每一步都会执行有返回值，而惰性链每一步没有返回值，而是等到最后一步才返回具体的值</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">3.函数式编程深入</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    高阶函数</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            //命令式</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var add = function(a,b){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return a+ b;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function math(fn,arr){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return fn(arr[0],arr[1]);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            math(add[7,2]);//3</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    它是一等公民</li><li style="list-style-position:inside;">    它是一个函数作为参数</li><li style="list-style-position:inside;">    以一个函数作为返回结果</li></ul><li style="list-style-position:inside;">    尾调用优化</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。函数调用自身，称为递归。如果尾调用自身，就是尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //不是尾递归无法优化</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function fn(n){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            if(n===1) return 1;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return nfn(n-1);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function fn(n,total){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            if(n===1) return total;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return fn(n-1,n<em>total);</em></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //es6强制使用尾递归</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    普通递归</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    普通递归时，内容需要记录调用的堆栈所处的深度和位置信息，在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。cpu计算和内存会消耗很多，而且当深度过深时，会出现堆栈溢出。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function sum(n){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                n===1&amp;&amp;return 1;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return n+sum(n-1);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(5)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+sum(4))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+sum(3)))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+sum(2))))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+(2+sum(1)))))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+(2+1))))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+(3+3)))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+(4+6))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            (5+10)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            15</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    尾递归</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    整个计算过程是线性的，调用一次sum(x,total)后，相关数据信息跟随进入下一个栈，不再放在堆栈上保存。当计算完值后，直接返回到最上层的sum(5,0).这能有效的防止堆栈溢出。</li><li style="list-style-position:inside;">    在ECMAScript6，我们将迎来尾递归优化，通过尾递归优化，JavaScript代码在解释成机器码的时候，将会向while看齐，也就是说，同时拥有数学表达能力和while的效能。</li></ul></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function sum(x,total){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                n===1&amp;&amp;return x + total;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return sum(x-1,x+total);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(5,0)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(4,5)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(3,9)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(2,12)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            sum(1,14)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            15</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    闭包</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    如下例子，虽然外层的makePowerFn函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不释放，因此power依旧可以被powerFn函数访问，这样就形成了闭包。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function makePowerFn(power){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function powerFn(base){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return Math.pow(base,power);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return powerFn;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var square = makePowerFn(2);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        square(3);//9</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    范畴与容器</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.我们可以把‘范畴’想像成一个容器，里面包含两样东西。值、值得变形关系，也就是函数。</li><li style="list-style-position:inside;">    2.范畴论使用函数，表达范畴之间的关系</li><li style="list-style-position:inside;">    3.伴随着范畴论的发展，就发展出一整套函数运算的方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的函数式编程。</li><li style="list-style-position:inside;">    4.本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其它的事情，否则就无法满足函数运算法则了。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">     </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.函数不仅可以用于同一个范畴之中值得转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）</li><li style="list-style-position:inside;">    2.函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变成另一个容器。</li></ul></ul><div yne-bulb-block="image"><img alt="" src="images/replace-img.png" data-media-type="image" data-original="https://note.youdao.com/yws/public/resource/aec0c2734c30aebc54626244a94fcd9e/xmlnote/384E272960584913ADB08795345A955F/21794" style="cursor: pointer;"></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    容器、Functor</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    $(‘’)返回的对象并不是一个原生的dom对象，而是对于原生对象的一种封装，这在某种意义上就是一个容器（但它并不函数式）</li><li style="list-style-position:inside;">    Functor(函子)是遵守一些特定规则的容器类型</li><li style="list-style-position:inside;">    任何具有map方法的数据结构，都可以当做函子的实现。</li><li style="list-style-position:inside;">    Functor是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由选择何时何地地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。</li></ul><li style="list-style-position:inside;">    函子的代码实现</li></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  Container  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.<strong>value =  x;</strong></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //函数式编程一般约定，函子有一个of方法,用来实现new操作</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Container.of =  x=&gt;new Container(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //一般约定，函子的标志就是容器具有map方法。该方法将容器里面的额每一个值，映射到另一个容器。</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Container.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return Container.of(f(this.value));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Container.of(3)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            .map(x=&gt;x+1)          //=&gt;Container(4)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            .map(x=&gt;’result  is’+  x);      //=&gt;Container(‘result is 4’)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ————–es6写法—————-</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class  Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            constructor(val){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                this.val =  val;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return new Functor(f(this.val))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //写法一，这样写在生成新函子的时候，用了new命令。不符合函数式编程，因为new命令式面向对象的标志。</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //函数式编程一般约定，函子有一个of方法，用来生成新的容器。</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        (new Functor(2)).map(function  (two){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return two +2;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        });</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Functor (4);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //写法二，修改</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Functor.of =  function(val){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Functor(val);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        };</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Functor.of(2).map(function(two){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return two +  2;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Functor(4)</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    上面代码中，Functor是一个函子，它的map方法接受函数作为参数，然后返回一个新的函子，里面包含的值是被f处理过的f(this.val)。一般约定，函子的标志是拥有map方法。该方法将容器里面的每一个值，映射到另一个容器。</li><li style="list-style-position:inside;">    上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值得容器—-函子。函子本身具有对外接口（map方法），各种函数运算就是运算符，通过接口接入容器，引发容器里面的变形。因此，学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。</li></ul><li style="list-style-position:inside;">    Maybe函子</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //当传入空值的时候会报错，</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Functor.of(null).map(function(s){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return  s.toUpperCase();//Cannot read property ‘toUpperCase’ of null</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ————————————</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //通过Maybe函子进行处理如下,先对值进行一次判断</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class  Maybe  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.val?Maybe.of(f(this.val)):Maybe.of(null);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.of(null).map(function(s){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return s.toUpperCase();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Maybe(null)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ——————————-</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //Maybe函子</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  Maybe  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.<strong>value =  x;</strong></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.of  =  function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Maybe(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return this.isNothing()?Maybe.of(null):Maybe.of(f(this.value));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.prototype.isNothing =  function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return (this.<strong>value ===  null||  this.</strong>value ===  undefined);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //新的容器我们称之为Maybe(原型来自Haskell)</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    注：Haskell是函数式（一切通过函数调用来完成）、静态、隐式类型（类型由编译器检测，类型声明不是必须的）、惰性（除非必要，否则什么也不做）的语言。</li></ul><li style="list-style-position:inside;">    错误处理、Either</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.我们的容器能做的事情太少了，try/catch/throw并不是‘纯’的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。</li><li style="list-style-position:inside;">    2.Promise是可以调用catch来集中处理错误的</li><li style="list-style-position:inside;">    3.事实上，Either并不只是用来处理错误的，它表示了逻辑或，范畴学里边的coproducts</li><li style="list-style-position:inside;">    条件运算符if…else是最常见的运算之一，函数式编程里面，使用either函子表达。Either函子内部有两个值：左值（left）和右值（right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //代替try…catch</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class Either  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            constructor(left,right){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                this.left =  left;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                this.right =  right;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.right?Either.of(this.left,f(this.right)):Either.of(f(this.left),this.right);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of =  function(left,right){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Either(left,right);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var addOne =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return x+1;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of(5,6).map(addOne);//Either(5,7)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of(1,null).map(addOne);//Either(2,null)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Either.of({address:’xxx’},currentUser.address).map(updatefield);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ———————————————————————-</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  Left  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.<strong>value =  x;</strong></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var Right  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            thsi.value =  x;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Left.of  =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Left(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Right.of =  function(x){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new Right(x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Left.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return this;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Right.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return Right.of(f(this.<strong>value));</strong></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    Left和Right唯一区别就在于map方法的实现，Right.map的行为和我们之前提到的map函数一样。但是Left.map就很不同了：它不会对容器做任何事情，只是简单的把这个容器拿进来又扔出去。这个特性意味着，Left可以用来传递一个错误消息。</li><li style="list-style-position:inside;">    示例：</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var   getAge =  user=&gt;user.age?Right.of(user.age):Left.of(“ERROR”);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        getAge({name:’wang’,age:’21’}).map(age=&gt;’age is’+  age);//Right(‘age is 21’);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        getAge({name:’wang’}).map(age=&gt;’age is’+  age);//Left(‘ERROR’)，因为age不存在执行Left</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //left可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层又有一层的try/catch</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    AP</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    AP因子</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    1.函数里面包含的值，完全可能是函数。我们可以想象这样一个情况，一个函子的值是数值，另一个函子的值是函数。</li></ul><li style="list-style-position:inside;">    AP函子</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class  Ap  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            ap(F){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return Ap.of(this.val(F.val));</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Ap.of(addTwo).ap(Function.of(2));</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    IO</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.真正的程序总要去接触肮脏的世界</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function  readLocalStorage(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return window.localStorage;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            } </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    2.IO跟前面那几个Functor不同的地方在于，它的value是一个函数。它把不纯的操作（比如IO、网络请求、dom）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO包含的是被包裹的操作返回值。</li><li style="list-style-position:inside;">    3.IO其实也是惰性求值</li><li style="list-style-position:inside;">    4.IO负责解决调用链积累的很多不纯的操作，带来的复杂性和不可维护性。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        import  _from ‘lodash’;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var compose =  <em>.flowRight;</em></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var IO  =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            this.__value =  f;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        } </div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        IO.of  =  x =&gt;new IO(=&gt;x);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        IO.prototype.map =  function(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new IO (compose(f,this.<strong>value))</strong></div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ————————————-</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        import   _from ‘lodash’;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var compose =  _.flowRight;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class IO  extends Monad{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            map(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return IO.of(compose(f,this.value))</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ———–IO函子—————————–</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  fs =  require(‘fs’);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var rea的File  =  function(filename){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return new IO(function(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return fs.readFileSync(filename,’utf-8’);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            })</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        readFile(‘./user.txt’)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .flatMap(tail)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .flatMap(print)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        //等同于</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        readFile(‘./user.txt’)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .chain(tail)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        .chain(prinit)</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    小结</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    我们先后用到了Maybe、Either、IO这三种强大的Functor，在链式调用、惰性求值、错误捕获、输入输出中都发挥着巨大的作用，事实上Functor远不止这三种。</li><li style="list-style-position:inside;">    1.如何处理嵌套的Functor呢？（Maybe(IO(42))）</li><li style="list-style-position:inside;">    2.如何处理一个由非纯的或异步的操作序列呢？</li></ul><li style="list-style-position:inside;">    Monad</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    1.Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</li><li style="list-style-position:inside;">    2.Promise就是一种Monad</li><li style="list-style-position:inside;">    3.Monad让我们避开了嵌套地狱，可以轻松的进行深度嵌套的函数式编程，比如IO和其它异步任务。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        Maybe.of(Maybe.of({name:’wang’,number:12})) ;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        class Monad  extends Functor{</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            join(){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.val;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            flatMap(f){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return this.map(f).join();</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    Monad函子的作用是，总是返回一个单层的函子。它有一个flatMap的方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。如果函数返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，join方法保证了flatMap方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">3.流行的几大函数式编程库</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    RxJS(学习api)</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    RxJS从诞生以来一直都不温不火，但它函数响应式编程（Function Reactive  programming，FRP）的理念非常先进，虽然或许对于大部分应用环境来说，外部输入事件并不是太频繁，并不需要引入一个如此庞大的FRP体系，但我们也可以了解一下它有哪些优秀的特性。</li><li style="list-style-position:inside;">    在RxJS中，所有的外部输入（用户输入、网络请求等等）都被视作一种事件流</li><li style="list-style-position:inside;">    用户点击了按钮–&gt;网络请求成功-&gt;用户输入键盘-&gt;某个定时事件发生-&gt;这种事件流特别适合处理游戏，如下</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            var  clicks =  Rx.Observable</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                .fromEvent(document,’click’)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                .bufferCount(2)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                .subscribe(x=&gt;console.log(x));//打印出前两次点击事件 </div><ul style="list-style-type:disc;"><ul style="list-style-type:circle"><li style="list-style-position:inside;">    响应式编程是继承自函数式编程，声明式的，不可变的，没有副作用的是函数式编程的三大护法。其中不可变武功最深。一直使用面向对象编程的我们，习惯了使用变量存储和追踪程序的状态。RxJS从函数式编程范式中借鉴了很多东西，比如链式调用，惰性求值等。</li><li style="list-style-position:inside;">    在函数中与函数作用域之外的一切事物有交互就产生了副作用。比如读写文件，在控制台打印语句，修改页面元素css等。在RxJS中，把副作用问题推给了订阅者来解决。</li></ul><li style="list-style-position:inside;">    cycleJS</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    cyclejs是一个rxjs的框架，它是一个彻彻底底的FRP理念的框架和react一样支持virtula dom，jsx语法，但现在似乎没有看到大型的应用经验。</li><li style="list-style-position:inside;">    本质上讲，它就是在rxjs的基础上加了对virtual dom、容器组件的支持，比如下面就是一个简单的开关按钮</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            function  main(sources){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                const sinks =  {</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                    DOM:sources.DOM.select(‘input’).events(‘click’)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        .map(ev=&gt;ev.target.checked)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        .startWidth(false)</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        .map(toggled=&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;div&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;input type=”check”  /&gt;toggle me</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;p&gt;{toggled?’ON’:’off’}&lt;/p&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                            &lt;/div&gt;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                        )</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                };</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                return sinks;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            const drivers =  {</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">                DOM:makeDOMDrive(“#app”);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            run(main,drives);</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    LodashJS、lazy（惰性求值）</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    lodash是一个具有一致接口、模块化、高性能等特性的javascript工具库，是udnerscorejs的fork，其最初目标也是“一致的浏览器行为，并改善性能”。</li><li style="list-style-position:inside;">    lodash采用延迟计算，意味着我们的链式方法在显示或者隐式的value()调用之前是不会执行的，因此lodash可以进行shortcut（捷径），fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。</li><li style="list-style-position:inside;">    就如同jquery在全部函数前加全局的$一样，lodash使用全局的_来提供对工具的快速访问。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var  abc =  function(a,b,c){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return [a,b,c];</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var curried =  _.curry(abc);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        curried(1)(2)(3);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        ——————————</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        function square(n){</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">            return nn;</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        }</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        var addSquare =  <em>.flowRight(square,</em>.add);</div><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">        addSquare(1,2);//9</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    underscoreJS</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    underscorejs是一个javaScript工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何javaScript内置对象。他解决了这个问题：‘如果我们面对一个空白的html页面，并希望立即开始工作，我们需要什么？’它弥补了jquery没有实现功能，同时又是backbone必不可少的部分。</li><li style="list-style-position:inside;">    undescore提供了100多个函数，包括常用的：map,filter,invoke,当然还有更多专业的辅助函数，如：函数绑定、javaScript模板功能、创建快速索引、强类型相等测试等等。</li></ul><li style="list-style-position:inside;">    ramdajs</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">    ramda是一个非常优秀的额sj工具库，跟同类比更函数式，主要体现在以下几个原则</li><ul style="list-style-type:square"><li style="list-style-position:inside;">    1.ramda里面的提供的函数全部都是curry的，意味着函数没有默认参数可选参数从而减轻认知函数的难度。</li><li style="list-style-position:inside;">    2.radma推崇pointfree简单的说是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。</li><li style="list-style-position:inside;">    3.ramda有个非常好用的参数占位符R._大大减轻了函数在pointfree过程中参数位置的问题。</li><li style="list-style-position:inside;">    相比undescore/lodash感觉要干净很多</li></ul></ul></ul><div style="display:table; white-space: pre-wrap;" id="4371-1534947459296" yne-bulb-block="todo"><div style="border: 1px solid rgb(187, 187, 187); width: 1em; height: 1em; line-height: 1; position: relative; display:inline-flex;"></div><div style="display: table-cell; word-break: break-word; padding-left: 8px; width: 100%;">任务看下rxjs官方的api，把underscorejs（有点不是纯粹的函数式编程，有点老了，不过代码非常有学习的意义，学函数式编程的思想，js编程的技巧）的源码看一下 </div></div><div style="display:table; white-space: pre-wrap;" id="8179-1534947370178" yne-bulb-block="todo"><div style="border: 1px solid rgb(187, 187, 187); width: 1em; height: 1em; line-height: 1; position: relative; display:inline-flex;"></div><div style="display: table-cell; word-break: break-word; padding-left: 8px; width: 100%;">lodashjs不推荐读源码，比较复杂，学lodashjs，</div></div><div style="white-space: pre-wrap;" id="8762-1534939530883" yne-bulb-block="heading"><span style="font-weight:bold;">4.函数式编程的实际应用场景</span></div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">易调试、热部署、并发</li><ul style="list-style-type:circle"><li style="list-style-position:inside;">1.函数式编程中的每个符号都是const的，于是没有什么函数会有副作用。谁也不能在运行时候修改任何东西，也没有函数可以修改再它的作用域之外修改什么值给其它函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而且影响其返回值的唯一因素就是参数。</li><li style="list-style-position:inside;">2.函数式编程不需要考虑死锁（deadlock），因为它不修改变量，所以根本不存在锁线程问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心的把工作分摊到多个线程，部署‘并发编程’（concurrency）</li><li style="list-style-position:inside;">3.函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</li></ul></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">5.单元测试</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    严格函数式编程的每一个符号都是对直接量或者表达式结果的引用，没有函数产生副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其它函数使用（如类成员，或全局变量）。这意味着函数求值的结果只是返回值，而唯一影响其返回值的就是函数的参数。</li><li style="list-style-position:inside;">    这是单元测试者的梦中仙境（wet  dream）。对被测试程序中的每个函数你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在java或c++中只检查函数的返回值还不够—-我们还必须验证这个函数可能修改了的外部状态。</li></ul><div style="white-space: pre-wrap;" yne-bulb-block="paragraph">6.总结与补充</div><ul style="list-style-type:disc;"><li style="list-style-position:inside;">    函数式编程不应该被视为灵丹妙药。相反，它应该被视为我们现有工具箱的一个很自然的补充—它带来了更高的可组合性，灵活性以及容错性。现在的javascript库已经开始尝试拥抱函数式编程的概念以获取这些优势。redux作为一种flux的变种实现，核心理念也是状态机的函数式编程。</li><li style="list-style-position:inside;">    函数对于外部状态的依赖是造成系统复杂性大大提高的主要原因</li><li style="list-style-position:inside;">    要让函数尽可能的纯净</li><li style="list-style-position:inside;">    我们可能没有机会在生成环境中自己去实现这样的玩具级Functor，但通过了解它们的特性会让你产生对于函数式编程的意识。</li><li style="list-style-position:inside;">    软件工程上讲，‘没有银弹’，函数式编程同样也不是万能的，它与烂大街的oop一样，只是一种编程范式而已。很多实际应用中是很难用函数式去表达的，选择oop亦或是其它编程式或许更简单。但我们要注意到函数式编程的核心理念，如果说oop降低复杂度是靠良好的额封装、继承、多态以及接口定义的话，那么函数式编程就是通过纯函数以及他们的组合、柯里化、Functor等技术来降低系统复杂度，而react，rxjs，cyclejs正式这种理念的代言。让门一起拥抱函数式编程，打开程序的大门。</li></ul></div></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; JavaScript函数式编程：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="note" scheme="http://WangGenzhen.github.io/categories/note/"/>
    
    
      <category term="JavaScript" scheme="http://WangGenzhen.github.io/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://WangGenzhen.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法学习</title>
    <link href="http://WangGenzhen.github.io/2018/08/23/markdown/"/>
    <id>http://WangGenzhen.github.io/2018/08/23/markdown/</id>
    <published>2018-08-23T02:05:41.000Z</published>
    <updated>2018-10-13T07:16:15.987Z</updated>
    
    <content type="html"><![CDATA[<p><strong> markdown语法学习：</strong> <excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><blockquote><p>注：#后面保持空格</p></blockquote><h1 id="2-目录生成asdfsdkjlkjffdkfjd"><a href="#2-目录生成asdfsdkjlkjffdkfjd" class="headerlink" title="2.目录生成asdfsdkjlkjffdkfjd"></a>2.目录生成asdfsdkjlkjffdkfjd</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><blockquote><p>注：根据标题生成目录，兼容性一般</p></blockquote><h1 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用,,..,,,,"></a>3.引用,,..,,,,</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;hello</span><br></pre></td></tr></table></figure><h1 id="4-引用嵌套"><a href="#4-引用嵌套" class="headerlink" title="4.引用嵌套"></a>4.引用嵌套</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;a</span><br><span class="line">&gt;&gt;b</span><br><span class="line">&gt;&gt;&gt;c</span><br></pre></td></tr></table></figure><blockquote><p>演示：</p></blockquote><blockquote><p>a</p><blockquote><p>b</p><blockquote><p>c</p></blockquote></blockquote></blockquote><h1 id="5-行内标记"><a href="#5-行内标记" class="headerlink" title="5.行内标记"></a>5.行内标记</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hello`</span><br></pre></td></tr></table></figure><blockquote><p>演示：</p></blockquote><p>标记之外<code>被标记内容</code>标记之外</p><h1 id="6-代码块"><a href="#6-代码块" class="headerlink" title="6.代码块"></a>6.代码块</h1><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>也可用tab缩进或敲4个空格</p></blockquote><h1 id="7-代码块自定义颜色"><a href="#7-代码块自定义颜色" class="headerlink" title="7.代码块自定义颜色"></a>7.代码块自定义颜色</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'red'</span>;</span><br></pre></td></tr></table></figure><h1 id="8-插入链接"><a href="#8-插入链接" class="headerlink" title="8.插入链接"></a>8.插入链接</h1><blockquote><p>内联式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[龙心且行](longxin.site)</span><br></pre></td></tr></table></figure></p></blockquote><p><a href="http://longxin.site" target="_blank" rel="noopener">龙心且行</a></p><blockquote><p>引用式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[龙心且行][blog]</span><br><span class="line">[blog]:longxin.site</span><br></pre></td></tr></table></figure></p></blockquote><p><a href="http://longxin.site" target="_blank" rel="noopener">龙心且行</a>   </p><h1 id="9-插入图片"><a href="#9-插入图片" class="headerlink" title="9.插入图片"></a>9.插入图片</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![image](图片地址)</span><br></pre></td></tr></table></figure><p><img src="http://item.dsconsulting.com/meituan_university/images/title.png" alt=""></p><h1 id="10-插入图片带有链接"><a href="#10-插入图片带有链接" class="headerlink" title="10.插入图片带有链接"></a>10.插入图片带有链接</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![image](图片地址)](链接地址)</span><br></pre></td></tr></table></figure><h1 id="11-序表"><a href="#11-序表" class="headerlink" title="11.序表"></a>11.序表</h1><h2 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. one</span><br><span class="line">2. two</span><br><span class="line">3. three</span><br></pre></td></tr></table></figure><ol><li>one</li><li>two</li><li>three<blockquote><p>注：点后保持空格</p></blockquote><h2 id="无序"><a href="#无序" class="headerlink" title="无序"></a>无序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* one</span><br><span class="line">* two</span><br></pre></td></tr></table></figure></li></ol><ul><li>one</li><li>two<h2 id="序表嵌套"><a href="#序表嵌套" class="headerlink" title="序表嵌套"></a>序表嵌套</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. one</span><br><span class="line">    1.one</span><br><span class="line">    2.two</span><br><span class="line">2.two</span><br><span class="line">    * one</span><br><span class="line">    *two</span><br></pre></td></tr></table></figure></li></ul><ol><li>one<br> 1.one1<br> 2.one2</li><li>two<ul><li>two1</li><li>two2<h2 id="序表嵌套代码块"><a href="#序表嵌套代码块" class="headerlink" title="序表嵌套代码块"></a>序表嵌套代码块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* one</span><br><span class="line"></span><br><span class="line">    var a = 1;//与上行保持空行，并加两个tab</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>one   </p><pre><code>var a =1</code></pre><h1 id="12-表格"><a href="#12-表格" class="headerlink" title="12.表格"></a>12.表格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|a|b|c|</span><br><span class="line">|:-:|:-|-:|</span><br><span class="line">|内容|内容二|内容三|</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">内容</td><td style="text-align:left">内容二</td><td style="text-align:right">内容三</td></tr></tbody></table><blockquote><p>注：：代表对齐方式，：与|之间不要有空格，否则对齐会有些不兼容</p></blockquote><h1 id="13-语义标记"><a href="#13-语义标记" class="headerlink" title="13.语义标记"></a>13.语义标记</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">斜体 *斜体* 或 _斜体_</span><br><span class="line">加粗 **加粗**</span><br><span class="line">斜体加粗 ***斜体加粗***   或  **_加粗斜体_**</span><br><span class="line">删除线  ~~删除线~~</span><br></pre></td></tr></table></figure><p>斜体 <em>斜体</em> 或 _斜体_<br>加粗 <strong>加粗</strong><br>斜体加粗 <strong><em>斜体加粗</em></strong>   或  <strong><em>加粗斜体</em></strong><br>删除线  <del>删除线</del></p><h1 id="14-语义标签"><a href="#14-语义标签" class="headerlink" title="14.语义标签"></a>14.语义标签</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">斜体 &lt;i&gt;斜体&lt;i&gt;</span><br><span class="line">加粗 &lt;b&gt;加粗&lt;/b&gt;</span><br><span class="line">强调 &lt;em&gt;强调&lt;/em&gt;</span><br><span class="line">上标 z&lt;sup&gt;a&lt;/sup&gt;</span><br><span class="line">下标 z&lt;sub&gt;a&lt;/sub&gt;</span><br><span class="line">键盘文本 &lt;kbd&gt;ctrl&lt;/kbd&gt;</span><br></pre></td></tr></table></figure><p>斜体 <i>斜体<i><br>加粗 <b>加粗</b><br>强调 <em>强调</em><br>上标 z<sup>a</sup><br>下标 z<sub>a</sub><br>键盘文本 <kbd>ctrl</kbd>   </i></i></p><h1 id="15-格式化文本"><a href="#15-格式化文本" class="headerlink" title="15.格式化文本"></a>15.格式化文本</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">写法一</span><br><span class="line">&lt;pre&gt;</span><br><span class="line">    hello</span><br><span class="line">        word</span><br><span class="line">    hello</span><br><span class="line">&lt;/pre&gt;    </span><br><span class="line">  </span><br><span class="line">写法二</span><br></pre></td></tr></table></figure><pre><code>    hello        word<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"># 16.公式</span><br></pre></td></tr></table></figure>$ x \href{why-equal.html}{=} y^2 + 1 $</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 17.分隔符</span><br></pre></td></tr></table></figure><pre><code>***---</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">&gt;注：最少三个***或三个---</span><br><span class="line"># 18.脚注</span><br></pre></td></tr></table></figure><pre><code>Markdown[^1]      [^1]: markdown是一种纯文本标记语言</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 19.自动邮箱链接</span><br></pre></td></tr></table></figure><pre><code>&lt;1280210282@qq.com&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 20.流程图</span><br><span class="line">```flow                     // 流程</span><br><span class="line">st=&gt;start: 开始|past:&gt; http://www.baidu.com // 开始</span><br><span class="line">e=&gt;end: 结束              // 结束</span><br><span class="line">c1=&gt;condition: 条件1:&gt;http://www.baidu.com[_parent]   // 判断条件</span><br><span class="line">c2=&gt;condition: 条件2      // 判断条件</span><br><span class="line">c3=&gt;condition: 条件3      // 判断条件</span><br><span class="line">io=&gt;inputoutput: 输出     // 输出</span><br><span class="line">//----------------以上为定义参数-------------------------</span><br><span class="line"></span><br><span class="line">//----------------以下为连接参数-------------------------</span><br><span class="line">// 开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束</span><br><span class="line">st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;e</span><br><span class="line">c1(no)-&gt;e                   // 条件1不满足-&gt;结束</span><br><span class="line">c2(no)-&gt;e                   // 条件2不满足-&gt;结束</span><br><span class="line">c3(no)-&gt;e                   // 条件3不满足-&gt;结束</span><br></pre></td></tr></table></figure><h1 id="21-参考地址"><a href="#21-参考地址" class="headerlink" title="21.参考地址"></a>21.参考地址</h1><p><a href="https://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="noopener">Markdown语法整理大集合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; markdown语法学习：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="note" scheme="http://WangGenzhen.github.io/categories/note/"/>
    
    
      <category term="markdown" scheme="http://WangGenzhen.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>jQuery技术内幕</title>
    <link href="http://WangGenzhen.github.io/2018/08/19/jQuery%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    <id>http://WangGenzhen.github.io/2018/08/19/jQuery技术内幕/</id>
    <published>2018-08-19T15:05:41.000Z</published>
    <updated>2018-08-20T06:02:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> jQuery技术内幕：</strong> <excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h1 id="jQuery的无new操作"><a href="#jQuery的无new操作" class="headerlink" title="jQuery的无new操作"></a>jQuery的无new操作</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">(function (window, undefined) &#123;</span><br><span class="line">      /*</span><br><span class="line">       undefined = 42;</span><br><span class="line">       alert(undefined);//42 在函数内部就是变量，可以被赋值，在外部就是关键字，不可以不赋值</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       //new的话，s就能访问jq原型链的所有方法</span><br><span class="line">       //不new的话，q也就能访问jq原型链的所有方法-&gt;value</span><br><span class="line">      var s = new $(&apos;.test&apos;);</span><br><span class="line">      var q = $(&apos;.test&apos;);</span><br><span class="line">      //为什么呢？</span><br><span class="line">      //new jQuery -&gt;1构造函数 2prototype的方法</span><br><span class="line">      //new 第一步 返回一个init函数 原型链上挂载了一个init函数 没有主动的执行</span><br><span class="line">      //init没调用 被搁置了</span><br><span class="line">      //构造函数内部的 return new生效了</span><br><span class="line">      //jQuery.prototype</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">      var jQuery = function(selector,context)&#123;</span><br><span class="line">          //默默的做了一个new, 实际上就是new的原型jQuery.prototype</span><br><span class="line">          return new jQuery.fn.init(selector,context);</span><br><span class="line">      &#125;;</span><br><span class="line">      jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">          init:function(selector,context)&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line">  &#125;)(window);</span><br><span class="line">    //为什么绕一圈来new自己，而不是直接new自己？</span><br><span class="line">     为了得到jQuery原型链上的方法，暴露出去一个fn，fn上拥有jQuery原型链上所有的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //$.fn</span><br><span class="line">  //jQuery.fn.extend，给jQuery对象添加方法。直接挂载到了jQuery原型链上</span><br><span class="line">  //jQuery.extend，为扩展jQuery类本身.为类添加新的方法。 直接挂载到了jQuery对象身上</span><br><span class="line">  /*</span><br><span class="line">  //一般写插件</span><br><span class="line">  jQuery.fn.extend(&#123;</span><br><span class="line">      a:function()&#123;</span><br><span class="line">          console.log(123);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  $(&apos;&apos;).a();</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  //为jQuery类添加类方法，可以理解为添加静态方法。</span><br><span class="line">  jQuery.extend(&#123;</span><br><span class="line">      a:function()&#123;</span><br><span class="line">          console.log(13);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  $.a;//13</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   undefined = 42;</span><br><span class="line">   alert(undefined);//undefined 在外边是关键字</span><br><span class="line">   */</span><br></pre></td></tr></table></figure><h1 id="jQuery的链式调用如何实现的"><a href="#jQuery的链式调用如何实现的" class="headerlink" title="jQuery的链式调用如何实现的"></a>jQuery的链式调用如何实现的</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   //链式调用如何实现的</span><br><span class="line">   var s = &#123;</span><br><span class="line">       a:function()&#123;</span><br><span class="line">           console.log(&apos;first&apos;)</span><br><span class="line">       &#125;,</span><br><span class="line">       b:function()&#123;</span><br><span class="line">           console.log(&apos;second&apos;)</span><br><span class="line">       &#125;,</span><br><span class="line">       c:function()&#123;</span><br><span class="line">           console.log(&apos;three&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   s.a().b().c();//first 报错</span><br><span class="line">   var s = &#123;</span><br><span class="line">       a:function()&#123;</span><br><span class="line">           console.log(&apos;first&apos;);</span><br><span class="line">           return this//把指针return回去</span><br><span class="line">       &#125;,</span><br><span class="line">       b:function()&#123;</span><br><span class="line">           console.log(&apos;second&apos;);</span><br><span class="line">           return this</span><br><span class="line">       &#125;,</span><br><span class="line">       c:function()&#123;</span><br><span class="line">           console.log(&apos;three&apos;);</span><br><span class="line">           return this</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   s.a().b().c();//first second three</span><br><span class="line">   */</span><br></pre></td></tr></table></figure><h1 id="实现函数的重载"><a href="#实现函数的重载" class="headerlink" title="实现函数的重载"></a>实现函数的重载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//jQuery的一个用法，$()，括号中可以接受不同的值，实际上就引出了一个概念，函数的重载</span><br><span class="line">$(&apos;.test&apos;).val();//取值 赋值</span><br><span class="line">    //$(&apos;.test&apos;,&quot;td&quot;)</span><br><span class="line">    //$([&apos;.test&apos;,&quot;td&quot;])</span><br><span class="line">    //$(function()&#123;&#125;)</span><br><span class="line">    //$()-&gt;函数 函数的重载</span><br><span class="line">函数的重载：同一个函数接受不同的参数处理不同的事情    </span><br><span class="line">如何实现：</span><br><span class="line">  思路一：通过arguments.length进行判断，因为参数不知道会有多少个，每个都需要判断，穷举法不行</span><br><span class="line">  思路二：利用闭包可以保存变量的特性,</span><br><span class="line"></span><br><span class="line">         // old undefined obj.find-&gt;find0</span><br><span class="line">         // old find0    obj.find-&gt;find1</span><br><span class="line">         // old find1    obj.find-&gt;find2</span><br><span class="line"></span><br><span class="line">    function addMethod(obj,name,f)&#123;</span><br><span class="line">  console.log(f);//find0() find1() </span><br><span class="line">console.log(f.length);//0//1//函数的参数长度</span><br><span class="line">console.log(arguments.length);//3//3</span><br><span class="line">        var old = obj[name];//第一次undefined</span><br><span class="line">        obj[name] = function()&#123;</span><br><span class="line">//如果f的形参等于实参，则说明找到了合适的处理</span><br><span class="line">           if(f.length === arguments.length)&#123;</span><br><span class="line">               //this等于obj</span><br><span class="line">               return f.apply(this,arguments)</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">//如果f的形参不等于实参，则说明没有找到合适的处理，则会继续找</span><br><span class="line">               return old.apply(this,arguments)</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var people = &#123;</span><br><span class="line">        name:[&apos;张三&apos;,&apos;李四&apos;,&apos;王&apos;,&apos;高&apos;]</span><br><span class="line">    &#125;;</span><br><span class="line">    var find0 = function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;;</span><br><span class="line">    var find1 = function(name)&#123;</span><br><span class="line">        var arr = this.name;</span><br><span class="line">      for(var i = 0;i&lt;=arr.length;i++ )&#123;</span><br><span class="line">          if(arr[i] == name)&#123;</span><br><span class="line">              return arr[i]+&quot;在&quot;+i+&quot;位&quot;;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">var find2 =  function(name,age)&#123;\</span><br><span class="line">console.log(&quot;naemage&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    addMethod(people,&apos;find&apos;,find0);</span><br><span class="line">    addMethod(people,&apos;find&apos;,find1);</span><br><span class="line">    addMethod(people,&apos;find&apos;,find2);</span><br><span class="line">    // console.log(people.find());//(3) [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]</span><br><span class="line">     console.log(people.find(&quot;李四&quot;));//李四在1位</span><br><span class="line">     console.log(people.find(&quot;&quot;,&quot;&quot;));//</span><br></pre></td></tr></table></figure><h1 id="短路表达式"><a href="#短路表达式" class="headerlink" title="短路表达式"></a>短路表达式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> /*  var a ;</span><br><span class="line"> if(a)&#123;</span><br><span class="line">    foo = a;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    foo = b;</span><br><span class="line">   &#125;</span><br><span class="line"> var foo = a||b;//第一个为真就输出第一个，第一个为假第二个为真就输出第二个，第一个为假第二个为假就输出第二个</span><br><span class="line"> var foo = a&amp;&amp;b;//第一个为真，第二个为真输出第二个，第一个为假输出第一个*/                             </span><br><span class="line"></span><br><span class="line">执行顺序是从右往左</span><br><span class="line">示例：</span><br><span class="line">var a=1,b=2,c=0;</span><br><span class="line">a&amp;&amp;b&amp;&amp;c  //0</span><br><span class="line">实际执行顺序是：a&amp;&amp;(b&amp;&amp;c)</span><br></pre></td></tr></table></figure><h1 id="钩子机制"><a href="#钩子机制" class="headerlink" title="钩子机制"></a>钩子机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">  index1:1,</span><br><span class="line">  index2:2</span><br><span class="line"> &#125;</span><br><span class="line">var s = &quot;index1&quot;;</span><br><span class="line">data[s]&amp;&amp;data[s]();</span><br><span class="line">//如果有就执行函数</span><br><span class="line">//之前的话需要用if,else进行判断</span><br></pre></td></tr></table></figure><h1 id="jQuery-ready的实现"><a href="#jQuery-ready的实现" class="headerlink" title="jQuery ready的实现"></a>jQuery ready的实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jQuery的ready方法实现了当页面加载完成后才执行的效果，但它并不是window.onload或者document.onload的封装，而是使用标准w3c浏览器dom隐藏api和ie浏览器缺陷来完成的。代码如下：</span><br><span class="line">DOMContentLoaded =  function()&#123;</span><br><span class="line">    if(document.addEventListener)&#123;</span><br><span class="line">        //取消事件监听，执行ready方法</span><br><span class="line">        document.removeEventListener(&quot;DOMContentLoaded&quot;,DOMContentLoaded,false);</span><br><span class="line">        jQuery.ready();</span><br><span class="line">    &#125;else  if(document.readyState ===  &quot;complete&quot;)&#123;</span><br><span class="line">        //取消事件监听，执行ready方法</span><br><span class="line">        document.detachEvent(&quot;onreadystatechange&quot;,DOMContentLoaded);</span><br><span class="line">        jQuery.ready();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jQuery.ready.promise =  function(obj)&#123;</span><br><span class="line">    readyList =  jQuery.deferred();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; jQuery技术内幕：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="note" scheme="http://WangGenzhen.github.io/categories/note/"/>
    
    
      <category term="jQuery" scheme="http://WangGenzhen.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>ES5核心技巧</title>
    <link href="http://WangGenzhen.github.io/2018/08/14/ES5%E6%A0%B8%E5%BF%83%E6%8A%80%E5%B7%A7/"/>
    <id>http://WangGenzhen.github.io/2018/08/14/ES5核心技巧/</id>
    <published>2018-08-14T15:05:41.000Z</published>
    <updated>2018-08-20T05:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> ES5核心技巧：</strong> <excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h1 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">alert(a);  //function a()&#123;&#125;</span><br><span class="line">var a =  1;//a的赋值要保存当前的词法作用域</span><br><span class="line">function a()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">function a()&#123;&#125;</span><br><span class="line">var a;//发现没有值就直接被忽略了</span><br><span class="line">alert(a);//function a()&#123;&#125;</span><br><span class="line">a =  1;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h1 id="ES6里边的let作用域如何实现"><a href="#ES6里边的let作用域如何实现" class="headerlink" title="ES6里边的let作用域如何实现"></a>ES6里边的let作用域如何实现</h1><ul><li><p>try catch 实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    throw 1;</span><br><span class="line">&#125;catch(a)&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>with 实现（但是有问题）<br> *会延长作用域链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s =  &#123;</span><br><span class="line">    a:1</span><br><span class="line">&#125;</span><br><span class="line">with(s)&#123;</span><br><span class="line">    b =  2;//lbs    没有b就会在全局创建一个b，只对已存在的属性赋值</span><br><span class="line">&#125;</span><br><span class="line">alert(s.b)//undefined</span><br></pre></td></tr></table></figure></li></ul><h1 id="回收问题"><a href="#回收问题" class="headerlink" title="回收问题"></a>回收问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functon test()&#123;</span><br><span class="line">    var a =  1;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">    eval(&quot;&quot;);//加了这个a不会被回收，因为不确定会不会用到a</span><br><span class="line">    //with,try catch也不会回收</span><br><span class="line">    //不加这三个，a就会被回收</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h1 id="this问题"><a href="#this问题" class="headerlink" title="this问题"></a>this问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">this.a =  20;</span><br><span class="line">var s =  &#123;</span><br><span class="line">    a:30;</span><br><span class="line">    init:function()&#123;</span><br><span class="line">    alert(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">s.init();//30  s调用的</span><br><span class="line">var s =  s.init;   </span><br><span class="line">s();//20  </span><br><span class="line">---------------------------------------------------------</span><br><span class="line">this.a =  20;</span><br><span class="line">var s =  &#123;</span><br><span class="line">    a:30,</span><br><span class="line">    init:()=&gt;&#123;</span><br><span class="line">    alert(this.a);//箭头函数改变了this的指向,总是指向词法作用域，也就是最外层的obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">s.init();//20</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">this.a =  20;</span><br><span class="line">var s =  &#123;</span><br><span class="line">    a:30,</span><br><span class="line">    b:&#123;</span><br><span class="line">    a:30,</span><br><span class="line">    fn:()=&gt;&#123;</span><br><span class="line">    alert(&quot;fn&quot;+this.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">init:()=&gt;&#123;</span><br><span class="line">    alert(this.a);//箭头函数改变了this,找到父级最外边的作用域</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">s.init();//20</span><br><span class="line">s.b.fn();//20</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">function test()&#123;</span><br><span class="line">    this.a =  20;</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.a =  30;</span><br><span class="line">console.log((new test()).a)//20;原型链的优先级低于构造函数的优先级</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">class test&#123;</span><br><span class="line">    a()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.a =  function()&#123;</span><br><span class="line">console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log((new test).a());//2   之所以会输出2是因为整个类的实现是基于js的原型链实现的</span><br><span class="line">----------class是基于原型链实现的过程，上面的代码就等价与下面的代码---------</span><br><span class="line">function test()&#123;</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.a =  function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.a =  function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log((new test).a());//2</span><br><span class="line"> -----------------------------------------------------------------------</span><br><span class="line">class基于原型链实现原理</span><br><span class="line">class test&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">    this.a =  function()&#123;</span><br><span class="line">    console.log(0);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.a =  function()&#123;</span><br><span class="line">console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log((new test).a());//0   整个类是基于es的原型链实现的</span><br><span class="line"></span><br><span class="line">------------上面的代码等价于下面的代码------------</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    //test.constructor =  test;</span><br><span class="line">    this.a =  function ()&#123;</span><br><span class="line">    console.log(0)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.prototype.a =  function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;</span><br><span class="line">test.prototype.a =  function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log((new test).a());//0</span><br></pre></td></tr></table></figure><h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//还没定义就使用</span><br><span class="line">var  i;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    i  =  5;</span><br><span class="line">    let i;</span><br><span class="line">&#125;</span><br><span class="line">alert(i);/  报错，i is not defined</span><br></pre></td></tr></table></figure><h1 id="同步队列和异步队列，微任务和宏任务"><a href="#同步队列和异步队列，微任务和宏任务" class="headerlink" title="同步队列和异步队列，微任务和宏任务"></a>同步队列和异步队列，微任务和宏任务</h1><pre><code>js执行会生成一个同步队列和一个异步队列 异步队列包含（绑定的事件，ajax，延时），异步队列又分宏任务和微任务，浏览器加载的时候当同步队列的执行完毕之后会去异步队列取值 </code></pre><h1 id="按值传递和按引用传递"><a href="#按值传递和按引用传递" class="headerlink" title="按值传递和按引用传递"></a>按值传递和按引用传递</h1><ul><li>函数的参数如果是原始类型的值，传递方式是按值传递，这意味着在函数体内修改参数的值，不会影响到函数外部   </li><li>函数的参数如果是符合类型的值，传递方式是按引用传递，也就是传入函数的是原始值的地址，因此在函数内部修改参数，将会影响到原始值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function   s(m)&#123;</span><br><span class="line">    m.v =  5;//这个m和外边的m是不是一个m，只是指向同一个地址,可以这样写function s(a)&#123;a.v =  5&#125;,不会影响结果</span><br><span class="line">    //如果被重写了</span><br><span class="line">    m =  &#123;k:1&#125;;    这样就会弹出undefined，因为指向了新的地址</span><br><span class="line">&#125;</span><br><span class="line">var m =  &#123;a:1&#125;</span><br><span class="line">s(m);</span><br><span class="line">alert(m.v)//5</span><br></pre></td></tr></table></figure></li></ul><h1 id="巧妙使用js写法"><a href="#巧妙使用js写法" class="headerlink" title="巧妙使用js写法"></a>巧妙使用js写法</h1><h2 id="一句话写出0-100学生的等级"><a href="#一句话写出0-100学生的等级" class="headerlink" title="一句话写出0-100学生的等级"></a>一句话写出0-100学生的等级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s=70;</span><br><span class="line">(function a(c,n)&#123;</span><br><span class="line">    s&gt;=c?console.log(n):a(c-10,++n);</span><br><span class="line">&#125;)(90,1);</span><br></pre></td></tr></table></figure><h2 id="用一句话遍历变量a-a-’abc’"><a href="#用一句话遍历变量a-a-’abc’" class="headerlink" title="用一句话遍历变量a,a=’abc’"></a>用一句话遍历变量a,a=’abc’</h2><ul><li>1.对ES6的理解，Array.from(a);   </li><li>2.对ES5的灵活运用，Array.prototype.slice(a);</li><li>3.a.split(“”);</li></ul><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p><img src="https://raw.githubusercontent.com/WangGenzhen/learn/master/img/image.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; ES5核心技巧：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="note" scheme="http://WangGenzhen.github.io/categories/note/"/>
    
    
      <category term="ES5" scheme="http://WangGenzhen.github.io/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>github和hexo一步步搭建自己的博客</title>
    <link href="http://WangGenzhen.github.io/2018/08/14/github%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://WangGenzhen.github.io/2018/08/14/github一步步搭建自己的博客/</id>
    <published>2018-08-14T02:35:37.000Z</published>
    <updated>2018-08-20T05:25:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> github和hexo一步步搭建自己的博客：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>博客搭建<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>使用github pages服务搭建博客的好处：</strong></p><blockquote><p>1.全是静态文件，访问速度快；<br>2.免费方便，不需要服务器不需要后天；<br>3.可以随意绑定自己的域名；<br>4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；<br>5.博客内容可以轻松打包、转移、发布发布到其它平台。<br>6.……</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始一切之前，你必须已经：   </p><ul><li>有一个github账号   </li><li>安装了node、npm,并了解相关知识</li><li>安装了git<h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2>新建一个名为<strong><em>你的用户名.github.io</em></strong>的仓库，比如你的github用户名是<strong><em>user</em></strong>,那么新建的仓库名就是<strong><em>user.github.io</em></strong>（必须是你的用户名，否则无效），将来你的网站就可以通过<a href="http://user.github.iof访问了。" target="_blank" rel="noopener">http://user.github.iof访问了。</a>   <h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2>不绑定域名也是也是可以的，可以用默认的<strong><em>username.github.io</em></strong>来访问，如果想要拥有一个自己的域名也是可以的。<br>首先需要你注册一个域名，阿里云什么的都可以，价格也不贵。<br>域名配置最常见的有两种方式，CNAME和A记录，CNAME和A记录填写IP,IP可以通过ping一下<strong><em>你的用户名.github.io</em></strong>的IP。<br>然后到你的github项目根目录下新建一个CNAME的文件，里面填写你的域名。<h1 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h1>为什么要配置这个，因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了。所以使用ssh key来解决本地和服务器连接问题。<br>在终端中执行以下命令：<br><code>cd ~/.ssh</code><br>如果提示：no such file or directory说明你是第一次使用git。需要执行下面的命令：<br><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;&quot;</code><br>然后连续回车三次，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh/id_rsa.pub文件，记事本打开复制里面的内容，打开你的github主页，进入个人设置：<br><strong><em>SSH and GPG keys-&gt;New SSH key</em></strong><br>将刚复制的内容粘贴到key那里，title随便填，保存。   <h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><code>ssh -T git@github.com</code><br>如果提示Are you sure you want to continue connecting(yes/no),输入yes,然后会看到：   <blockquote><p>Hi username! You’ve successfully authnenticated,but Github does not provid shell access.<br>看到这个信息，说明SSH已配置成功。   </p></blockquote><h1 id="使用hexo博客"><a href="#使用hexo博客" class="headerlink" title="使用hexo博客"></a>使用hexo博客</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>hexo是一个简单、快速、强大的基于Github Pages的博客发布工具，支持Markdown格式，有众多优秀插件和主题。   <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><code>npm install hexo -g</code>    <h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>在电脑的某个地方新建一个为名blog的文件夹（名字随意取）   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd  blog的路径</span><br><span class="line">hexo init</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo s #启动服务</span><br></pre></td></tr></table></figure></li></ul><p>执行以上命令后，hexo就会在public文件夹生成相关html的文件，这些文件将来是要提交到github上去的。<br>这是访问<strong><em><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></em></strong>就可以看到内容了。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>默认的主题很丑，我们可以自己选一个好看的，我选的是<a href="https://github.com/WangGenzhen/black-blue" target="_blank" rel="noopener">balck-blue</a><br>首先下载这个主题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd blog路径</span><br><span class="line">git https://github.com/WangGenzhen/black-blue.git themes/black-blue</span><br></pre></td></tr></table></figure></p><p>修改_config.yml中的theme:landscape改为theme:black-blue,重新执行<code>hexo g</code>来重新生成。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果一切都配置好了，一句<code>hexo d</code> 就可以。   </p><ul><li>首先SSH key要配好   </li><li>其次,配置_config.yml中有关deploy的部分    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com/username/username.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></li></ul><p>此时如果执行hexo d，一般会报错<br>原因是还需要安装一个插件：   </p><pre><code class="angular2html">npm install hexo-deployer-git --save</code></pre><h2 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h2><p>现在访问<a href="http://username.github.io，就可以看到搭建好的博客了。" target="_blank" rel="noopener">http://username.github.io，就可以看到搭建好的博客了。</a></p><h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><p><a href="https://geeksblog.cc/hexo-githup-blog.html" target="_blank" rel="noopener">Hexo和github打造个人博客</a><br><a href="https://geeksblog.cc/hexo-theme.html" target="_blank" rel="noopener">Hexo自用黑色主题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; github和hexo一步步搭建自己的博客：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;博客搭建&lt;br&gt;
    
    </summary>
    
      <category term="note" scheme="http://WangGenzhen.github.io/categories/note/"/>
    
    
      <category term="博客" scheme="http://WangGenzhen.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github" scheme="http://WangGenzhen.github.io/tags/github/"/>
    
      <category term="hexo" scheme="http://WangGenzhen.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
