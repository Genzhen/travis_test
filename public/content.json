{"meta":{"title":"王根镇的博客","subtitle":"学习使用","description":"学习使用","author":"王根镇","url":"http://WangGenzhen.github.io"},"pages":[{"title":"","date":"2018-10-13T05:56:32.560Z","updated":"2018-08-14T12:08:54.458Z","comments":true,"path":"readme.html","permalink":"http://WangGenzhen.github.io/readme.html","excerpt":"","text":"学习使用bolg"},{"title":"about","date":"2018-08-14T07:49:32.000Z","updated":"2018-08-14T08:06:36.000Z","comments":true,"path":"about/index.html","permalink":"http://WangGenzhen.github.io/about/index.html","excerpt":"","text":"爱徒步,爱骑行,爱编程,爱运动,爱的太多了!"}],"posts":[{"title":"JavaScript函数式编程","slug":"JavaScript函数式编程","date":"2018-08-23T15:35:37.000Z","updated":"2018-08-23T15:47:27.156Z","comments":true,"path":"2018/08/23/JavaScript函数式编程/","link":"","permalink":"http://WangGenzhen.github.io/2018/08/23/JavaScript函数式编程/","excerpt":"JavaScript函数式编程：","text":"JavaScript函数式编程： （一）第一周JavaScript语言新发展【直播课】一、开学典礼二、JavaScript函数式编程1.函数式编程思维范畴论 Category Theory1. 函数式编程是范畴论的数学分支，是一门复杂的数学，人为世界上所有的概念都可以抽象出一个范畴 2.彼此之间存在某种关系概念、事物、对象等，都构成范畴。任何事物只要找出他们之间的关系，就能定义3.箭头表示范畴成员之间的关系，正式的名称叫做“态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的“变形”（transform）。通过态射，一个成员可以变形成另一个成员注：所有成员是一个集合，变形关系是函数函数式编程基础理论1.函数式编程(Function Programming)其实相对于计算机的历史而言，是一个非常古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于λ（lambda x=&gt;x2）演算，而λ演算并非设计于在计算机上执行，它是在20世纪30年代引入的一套用于研究函数定义、函数应用和递归的系统。2.函数式编程不是用函数来编程，也不是传统的面向过程编程。主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用3.JavaScript是披着C外衣的lisp4.真正的火热是随着React的高阶函数而逐步升温a.函数是一等公民。所谓“第一等公民”（first class）,指的是函数与其它数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。b.不可变量。在函数式编程中，我们通常理解的变量在函数式编程中也被函数代替了，在函数式编程中变量仅仅代表了某个表达式。这里所说的‘变量’是不能被修改的。所有的变量只能被赋一次初值。c.map&amp;reduce它们是最常用的函数式编程的方法。函数是“第一等公民”只用表达式，不用语句没有副作用不修改状态引用透明（函数运行只靠参数）2.函数式编程常用核心概念纯函数对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。 var s = [1,2,3,4]; s.slice(0,3); s.slice(0,3) s.splice(0,3);//splice会改变原数组 s.splice(0,3);优缺点优点：纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性。 import _ from ‘lodash’; var sin = _.memorize(x=&gt;{Math.sin(x)}); //第一次计算的时候会稍微慢一点 var a sin(7); //第二次有了缓存，速度极快 var b = sin(7); 在不纯的版本中，checkAge不仅取决于age还有外部依赖的便令min，纯的checkAge把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。 //不纯的 var min = 18; var checkAge = age=&gt;age&gt;min; //纯的 var checkAge = age=&gt;age&gt;18; 纯度和幂等性幂等性是指执行无数次后还具有相同的效果，同一个参数运行一次应该与连续运行两次的结果一致。幂等性在函数编程中与纯度相关，但又不一致。 Math.abs(Math.abs(-42));//42函数的柯里化传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。示例：柯里化上边的checkAge var checkAge = min=&gt;(age=&gt;age&gt;min); vae checkAge18 = checkAge(18); checkAge(20); ———-函数柯里化code————- //函数柯里化之前 function add(x,y){ return x+y; } add(1,2);//3 //柯里化之后 function addX(y){ return function (x){ return x+y; } } addX(2)(1);//3优缺点事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的‘缓存’，是一种非常高效的编写函数的方法 import {curry} from ‘lodash’; var match = curry((reg,str)=&gt;str.match(reg)); var filter = curry((f,arr)=&gt;arr.filter(f)); var haveSpace = match(/\\s+/g); haveSpace(“ffffff”); haveSpace(‘a b’); filter(haveSpace,[‘adsf’,’adfs adfs’]); filter(haveSpace)([‘adsf’,’adfs adfs’]);函数组合纯函数以及如何把它写出的洋葱代码h(g(f(x)))柯里化，为了解决函数嵌套的问题，需要用到函数组合。 代码示例 const compose = (f,g)=&gt;(x=&gt;f(g(x))); var first = arr=&gt;arr[0]; var reverse = arr =&gt;arr.reverse(); var last = compose(first,reverse); last([1,2,3,4,5]);Point Free把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。这个函数中，使用了str作为中间变量，但这个中间变量除了让代码变得长了一点以外是毫无意义的。const f=str=&gt;str.toUpperCase().split(‘’);优缺点这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。 var toUpperCase = word=&gt;word.toUpperCase(); var split = x=&gt;(str=&gt;str.split(x)); var f = compose(split(‘’,toUpperCase)); f(‘ad adsf ads’);声明式代码与命令式代码命令式代码的意思就是，我们通过编写一条又一条指令去让计算机执行一些动作，这其中一半都会涉及到很多繁杂的细节。而声明式代码就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步步的指示。代码示例： //命令式 let ceo = []; for(var i = 0;i &lt; compain.length;i++){ ceo.push(compain[i].ceo); } //声明式 let ceo = compain.map(c=&gt;c.ceo);优缺点函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的。专注于编写业务代码。优化代码时，目光只需要集中在这些稳定坚固的函数内部即可。相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用它的时候总是要考虑这些不干净的副作用。在复杂的系统中，这对于程序员的心智来说是极大的负担。惰性求值、惰性函数、惰性链在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于其它外部的状态，因此必须顺序执行。惰性求值示例 function ajax(){ if(XMLHttpRequest){ ajax = function(){ return new XMLHttpRequest(); } }else{ ajax = function(){ return new ActiceXObject(‘Microsoft.XMLHTTP’); } } } 惰性链new LazyChain([1,2,3]).add().xx();后边可以点点，但是和链式调用不一样，简单说就是，链式调用，每一步都会执行有返回值，而惰性链每一步没有返回值，而是等到最后一步才返回具体的值3.函数式编程深入 高阶函数 函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象 //命令式 var add = function(a,b){ return a+ b; } function math(fn,arr){ return fn(arr[0],arr[1]); } math(add[7,2]);//3 它是一等公民 它是一个函数作为参数 以一个函数作为返回结果 尾调用优化 指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。函数调用自身，称为递归。如果尾调用自身，就是尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。 //不是尾递归无法优化 function fn(n){ if(n===1) return 1; return nfn(n-1); } function fn(n,total){ if(n===1) return total; return fn(n-1,ntotal); } //es6强制使用尾递归 普通递归 普通递归时，内容需要记录调用的堆栈所处的深度和位置信息，在最底层计算返回值，再根据记录的信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层的调用函数。cpu计算和内存会消耗很多，而且当深度过深时，会出现堆栈溢出。 function sum(n){ n===1&amp;&amp;return 1; return n+sum(n-1); } sum(5) (5+sum(4)) (5+(4+sum(3))) (5+(4+(3+sum(2)))) (5+(4+(3+(2+sum(1))))) (5+(4+(3+(2+1)))) (5+(4+(3+3))) (5+(4+6)) (5+10) 15 尾递归 整个计算过程是线性的，调用一次sum(x,total)后，相关数据信息跟随进入下一个栈，不再放在堆栈上保存。当计算完值后，直接返回到最上层的sum(5,0).这能有效的防止堆栈溢出。 在ECMAScript6，我们将迎来尾递归优化，通过尾递归优化，JavaScript代码在解释成机器码的时候，将会向while看齐，也就是说，同时拥有数学表达能力和while的效能。 function sum(x,total){ n===1&amp;&amp;return x + total; return sum(x-1,x+total); } sum(5,0) sum(4,5) sum(3,9) sum(2,12) sum(1,14) 15 闭包 如下例子，虽然外层的makePowerFn函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不释放，因此power依旧可以被powerFn函数访问，这样就形成了闭包。 function makePowerFn(power){ function powerFn(base){ return Math.pow(base,power); } return powerFn; } var square = makePowerFn(2); square(3);//9 范畴与容器 1.我们可以把‘范畴’想像成一个容器，里面包含两样东西。值、值得变形关系，也就是函数。 2.范畴论使用函数，表达范畴之间的关系 3.伴随着范畴论的发展，就发展出一整套函数运算的方法。这套方法起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今天的函数式编程。 4.本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它用来写程序。为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其它的事情，否则就无法满足函数运算法则了。 1.函数不仅可以用于同一个范畴之中值得转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor） 2.函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变成另一个容器。 容器、Functor $(‘’)返回的对象并不是一个原生的dom对象，而是对于原生对象的一种封装，这在某种意义上就是一个容器（但它并不函数式） Functor(函子)是遵守一些特定规则的容器类型 任何具有map方法的数据结构，都可以当做函子的实现。 Functor是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由选择何时何地地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。 函子的代码实现 var Container = function(x){ this.value = x; } //函数式编程一般约定，函子有一个of方法,用来实现new操作 Container.of = x=&gt;new Container(x); //一般约定，函子的标志就是容器具有map方法。该方法将容器里面的额每一个值，映射到另一个容器。 Container.prototype.map = function(f){ return Container.of(f(this.value)); } Container.of(3) .map(x=&gt;x+1) //=&gt;Container(4) .map(x=&gt;’result is’+ x); //=&gt;Container(‘result is 4’) ————–es6写法—————- class Functor{ constructor(val){ this.val = val; } map(f){ return new Functor(f(this.val)) } } //写法一，这样写在生成新函子的时候，用了new命令。不符合函数式编程，因为new命令式面向对象的标志。 //函数式编程一般约定，函子有一个of方法，用来生成新的容器。 (new Functor(2)).map(function (two){ return two +2; }); //Functor (4); //写法二，修改 Functor.of = function(val){ return new Functor(val); }; Functor.of(2).map(function(two){ return two + 2; }) //Functor(4) 上面代码中，Functor是一个函子，它的map方法接受函数作为参数，然后返回一个新的函子，里面包含的值是被f处理过的f(this.val)。一般约定，函子的标志是拥有map方法。该方法将容器里面的每一个值，映射到另一个容器。 上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值得容器—-函子。函子本身具有对外接口（map方法），各种函数运算就是运算符，通过接口接入容器，引发容器里面的变形。因此，学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。 Maybe函子 函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。 //当传入空值的时候会报错， Functor.of(null).map(function(s){ return s.toUpperCase();//Cannot read property ‘toUpperCase’ of null }) ———————————— //通过Maybe函子进行处理如下,先对值进行一次判断 class Maybe extends Functor{ map(f){ return this.val?Maybe.of(f(this.val)):Maybe.of(null); } } Maybe.of(null).map(function(s){ return s.toUpperCase(); }) //Maybe(null) ——————————- //Maybe函子 var Maybe = function(x){ this.value = x; } Maybe.of = function(){ return new Maybe(x); } Maybe.prototype.map = function(f){ return this.isNothing()?Maybe.of(null):Maybe.of(f(this.value)); } Maybe.prototype.isNothing = function(){ return (this.value === null|| this.value === undefined); } //新的容器我们称之为Maybe(原型来自Haskell) 注：Haskell是函数式（一切通过函数调用来完成）、静态、隐式类型（类型由编译器检测，类型声明不是必须的）、惰性（除非必要，否则什么也不做）的语言。 错误处理、Either 1.我们的容器能做的事情太少了，try/catch/throw并不是‘纯’的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。 2.Promise是可以调用catch来集中处理错误的 3.事实上，Either并不只是用来处理错误的，它表示了逻辑或，范畴学里边的coproducts 条件运算符if…else是最常见的运算之一，函数式编程里面，使用either函子表达。Either函子内部有两个值：左值（left）和右值（right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。 //代替try…catch class Either extends Functor{ constructor(left,right){ this.left = left; this.right = right; } map(f){ return this.right?Either.of(this.left,f(this.right)):Either.of(f(this.left),this.right); } } Either.of = function(left,right){ return new Either(left,right); } var addOne = function(x){ return x+1; } Either.of(5,6).map(addOne);//Either(5,7) Either.of(1,null).map(addOne);//Either(2,null) Either.of({address:’xxx’},currentUser.address).map(updatefield); ———————————————————————- var Left = function(x){ this.value = x; } var Right = function(x){ thsi.value = x; } Left.of = function(x){ return new Left(x); } Right.of = function(x){ return new Right(x); } Left.prototype.map = function(f){ return this; } Right.prototype.map = function(f){ return Right.of(f(this.value)); } Left和Right唯一区别就在于map方法的实现，Right.map的行为和我们之前提到的map函数一样。但是Left.map就很不同了：它不会对容器做任何事情，只是简单的把这个容器拿进来又扔出去。这个特性意味着，Left可以用来传递一个错误消息。 示例： var getAge = user=&gt;user.age?Right.of(user.age):Left.of(“ERROR”); getAge({name:’wang’,age:’21’}).map(age=&gt;’age is’+ age);//Right(‘age is 21’); getAge({name:’wang’}).map(age=&gt;’age is’+ age);//Left(‘ERROR’)，因为age不存在执行Left //left可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层又有一层的try/catch AP AP因子 1.函数里面包含的值，完全可能是函数。我们可以想象这样一个情况，一个函子的值是数值，另一个函子的值是函数。 AP函子 class Ap extends Functor{ ap(F){ return Ap.of(this.val(F.val)); } } Ap.of(addTwo).ap(Function.of(2)); IO 1.真正的程序总要去接触肮脏的世界 function readLocalStorage(){ return window.localStorage; } 2.IO跟前面那几个Functor不同的地方在于，它的value是一个函数。它把不纯的操作（比如IO、网络请求、dom）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO包含的是被包裹的操作返回值。 3.IO其实也是惰性求值 4.IO负责解决调用链积累的很多不纯的操作，带来的复杂性和不可维护性。 import _from ‘lodash’; var compose = .flowRight; var IO = function(f){ this.__value = f; } IO.of = x =&gt;new IO(=&gt;x); IO.prototype.map = function(f){ return new IO (compose(f,this.value)) } ————————————- import _from ‘lodash’; var compose = _.flowRight; class IO extends Monad{ map(f){ return IO.of(compose(f,this.value)) } } ———–IO函子—————————– var fs = require(‘fs’); var rea的File = function(filename){ return new IO(function(){ return fs.readFileSync(filename,’utf-8’); }) } readFile(‘./user.txt’) .flatMap(tail) .flatMap(print) //等同于 readFile(‘./user.txt’) .chain(tail) .chain(prinit) 小结 我们先后用到了Maybe、Either、IO这三种强大的Functor，在链式调用、惰性求值、错误捕获、输入输出中都发挥着巨大的作用，事实上Functor远不止这三种。 1.如何处理嵌套的Functor呢？（Maybe(IO(42))） 2.如何处理一个由非纯的或异步的操作序列呢？ Monad 1.Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。 2.Promise就是一种Monad 3.Monad让我们避开了嵌套地狱，可以轻松的进行深度嵌套的函数式编程，比如IO和其它异步任务。 Maybe.of(Maybe.of({name:’wang’,number:12})) ; class Monad extends Functor{ join(){ return this.val; } flatMap(f){ return this.map(f).join(); } } Monad函子的作用是，总是返回一个单层的函子。它有一个flatMap的方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。如果函数返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，join方法保证了flatMap方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。3.流行的几大函数式编程库 RxJS(学习api) RxJS从诞生以来一直都不温不火，但它函数响应式编程（Function Reactive programming，FRP）的理念非常先进，虽然或许对于大部分应用环境来说，外部输入事件并不是太频繁，并不需要引入一个如此庞大的FRP体系，但我们也可以了解一下它有哪些优秀的特性。 在RxJS中，所有的外部输入（用户输入、网络请求等等）都被视作一种事件流 用户点击了按钮–&gt;网络请求成功-&gt;用户输入键盘-&gt;某个定时事件发生-&gt;这种事件流特别适合处理游戏，如下 var clicks = Rx.Observable .fromEvent(document,’click’) .bufferCount(2) .subscribe(x=&gt;console.log(x));//打印出前两次点击事件 响应式编程是继承自函数式编程，声明式的，不可变的，没有副作用的是函数式编程的三大护法。其中不可变武功最深。一直使用面向对象编程的我们，习惯了使用变量存储和追踪程序的状态。RxJS从函数式编程范式中借鉴了很多东西，比如链式调用，惰性求值等。 在函数中与函数作用域之外的一切事物有交互就产生了副作用。比如读写文件，在控制台打印语句，修改页面元素css等。在RxJS中，把副作用问题推给了订阅者来解决。 cycleJS cyclejs是一个rxjs的框架，它是一个彻彻底底的FRP理念的框架和react一样支持virtula dom，jsx语法，但现在似乎没有看到大型的应用经验。 本质上讲，它就是在rxjs的基础上加了对virtual dom、容器组件的支持，比如下面就是一个简单的开关按钮 function main(sources){ const sinks = { DOM:sources.DOM.select(‘input’).events(‘click’) .map(ev=&gt;ev.target.checked) .startWidth(false) .map(toggled=&gt; &lt;div&gt; &lt;input type=”check” /&gt;toggle me &lt;p&gt;{toggled?’ON’:’off’}&lt;/p&gt; &lt;/div&gt; ) }; return sinks; } const drivers = { DOM:makeDOMDrive(“#app”); } run(main,drives); LodashJS、lazy（惰性求值） lodash是一个具有一致接口、模块化、高性能等特性的javascript工具库，是udnerscorejs的fork，其最初目标也是“一致的浏览器行为，并改善性能”。 lodash采用延迟计算，意味着我们的链式方法在显示或者隐式的value()调用之前是不会执行的，因此lodash可以进行shortcut（捷径），fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。 就如同jquery在全部函数前加全局的$一样，lodash使用全局的_来提供对工具的快速访问。 var abc = function(a,b,c){ return [a,b,c]; } var curried = _.curry(abc); curried(1)(2)(3); —————————— function square(n){ return nn; } var addSquare = .flowRight(square,.add); addSquare(1,2);//9 underscoreJS underscorejs是一个javaScript工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何javaScript内置对象。他解决了这个问题：‘如果我们面对一个空白的html页面，并希望立即开始工作，我们需要什么？’它弥补了jquery没有实现功能，同时又是backbone必不可少的部分。 undescore提供了100多个函数，包括常用的：map,filter,invoke,当然还有更多专业的辅助函数，如：函数绑定、javaScript模板功能、创建快速索引、强类型相等测试等等。 ramdajs ramda是一个非常优秀的额sj工具库，跟同类比更函数式，主要体现在以下几个原则 1.ramda里面的提供的函数全部都是curry的，意味着函数没有默认参数可选参数从而减轻认知函数的难度。 2.radma推崇pointfree简单的说是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。 3.ramda有个非常好用的参数占位符R._大大减轻了函数在pointfree过程中参数位置的问题。 相比undescore/lodash感觉要干净很多任务看下rxjs官方的api，把underscorejs（有点不是纯粹的函数式编程，有点老了，不过代码非常有学习的意义，学函数式编程的思想，js编程的技巧）的源码看一下 lodashjs不推荐读源码，比较复杂，学lodashjs，4.函数式编程的实际应用场景易调试、热部署、并发1.函数式编程中的每个符号都是const的，于是没有什么函数会有副作用。谁也不能在运行时候修改任何东西，也没有函数可以修改再它的作用域之外修改什么值给其它函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而且影响其返回值的唯一因素就是参数。2.函数式编程不需要考虑死锁（deadlock），因为它不修改变量，所以根本不存在锁线程问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心的把工作分摊到多个线程，部署‘并发编程’（concurrency）3.函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。5.单元测试 严格函数式编程的每一个符号都是对直接量或者表达式结果的引用，没有函数产生副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其它函数使用（如类成员，或全局变量）。这意味着函数求值的结果只是返回值，而唯一影响其返回值的就是函数的参数。 这是单元测试者的梦中仙境（wet dream）。对被测试程序中的每个函数你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在java或c++中只检查函数的返回值还不够—-我们还必须验证这个函数可能修改了的外部状态。6.总结与补充 函数式编程不应该被视为灵丹妙药。相反，它应该被视为我们现有工具箱的一个很自然的补充—它带来了更高的可组合性，灵活性以及容错性。现在的javascript库已经开始尝试拥抱函数式编程的概念以获取这些优势。redux作为一种flux的变种实现，核心理念也是状态机的函数式编程。 函数对于外部状态的依赖是造成系统复杂性大大提高的主要原因 要让函数尽可能的纯净 我们可能没有机会在生成环境中自己去实现这样的玩具级Functor，但通过了解它们的特性会让你产生对于函数式编程的意识。 软件工程上讲，‘没有银弹’，函数式编程同样也不是万能的，它与烂大街的oop一样，只是一种编程范式而已。很多实际应用中是很难用函数式去表达的，选择oop亦或是其它编程式或许更简单。但我们要注意到函数式编程的核心理念，如果说oop降低复杂度是靠良好的额封装、继承、多态以及接口定义的话，那么函数式编程就是通过纯函数以及他们的组合、柯里化、Functor等技术来降低系统复杂度，而react，rxjs，cyclejs正式这种理念的代言。让门一起拥抱函数式编程，打开程序的大门。","categories":[{"name":"note","slug":"note","permalink":"http://WangGenzhen.github.io/categories/note/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://WangGenzhen.github.io/tags/JavaScript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://WangGenzhen.github.io/tags/函数式编程/"}]},{"title":"markdown语法学习","slug":"markdown","date":"2018-08-23T02:05:41.000Z","updated":"2018-10-13T07:16:15.987Z","comments":true,"path":"2018/08/23/markdown/","link":"","permalink":"http://WangGenzhen.github.io/2018/08/23/markdown/","excerpt":"markdown语法学习：","text":"markdown语法学习： 1.标题123456# h1## h2### h3#### h4##### h5###### h6 注：#后面保持空格 2.目录生成asdfsdkjlkjffdkfjd1[TOC] 注：根据标题\b生成目录，兼容性一般 3.引用,,..,,,,1&gt;hello 4.引用嵌套123&gt;a&gt;&gt;b&gt;&gt;&gt;c 演示： a b c 5.行内标记1`hello` 演示： 标记之外被标记内容标记之外 6.代码块123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 也可用tab缩进或敲4个空格 7.代码块自定义颜色1var color = 'red'; 8.插入链接 内联式1[龙心且行](longxin.site) 龙心且行 引用式12[龙心且行][blog][blog]:longxin.site 龙心且行 9.插入图片1![image](图片地址) 10.插入图片带有链接1[![image](图片地址)](链接地址) 11.序表有序1231. one2. two3. three one two three 注：点后\b保持空格 无序12* one* two one two序表嵌套1234561. one 1.one 2.two2.two * one *two one 1.one1 2.one2 two two1 two2序表嵌套代码块123* one var a = 1;//与上行保持空行，并加两个tab one var a =1 12.表格123|a|b|c||:-:|:-|-:||内容|内容二|内容三| a b c 居中 左对齐 右对齐 内容 内容二 内容三 注：：代表对齐方式，：与|之间不要有空格，否则对齐会有些不兼容 13.语义标记1234斜体 *斜体* 或 _斜体_加粗 **加粗**斜体加粗 ***斜体加粗*** 或 **_加粗斜体_**删除线 ~~删除线~~ 斜体 斜体 或 _斜体_加粗 加粗斜体加粗 斜体加粗 或 加粗斜体删除线 删除线 14.语义标签123456斜体 &lt;i&gt;斜体&lt;i&gt;加粗 &lt;b&gt;加粗&lt;/b&gt;强调 &lt;em&gt;强调&lt;/em&gt;\b上标 z&lt;sup&gt;a&lt;/sup&gt;下标 z&lt;sub&gt;a&lt;/sub&gt;键盘文本 &lt;kbd&gt;ctrl&lt;/kbd&gt; 斜体 斜体加粗 加粗强调 强调上标 za下标 za键盘文本 ctrl 15.格式化文本12345678写法一&lt;pre&gt; hello word hello&lt;/pre&gt; 写法二 hello word 12```# 16.公式 $ x \\href{why-equal.html}{=} y^2 + 1 $ 1# 17.分隔符 *** --- 1234***---&gt;注：最少三个***或\b三个---# 18.脚注 Markdown[^1] [^1]: markdown是一种纯文本标记语言 1# 19.自动邮箱链接 &lt;1280210282@qq.com&gt; 12345678910111213141516# 20.流程图```flow // 流程st=&gt;start: 开始|past:&gt; http://www.baidu.com // 开始e=&gt;end: 结束 // 结束c1=&gt;condition: 条件1:&gt;http://www.baidu.com[_parent] // 判断条件c2=&gt;condition: 条件2 // 判断条件c3=&gt;condition: 条件3 // 判断条件io=&gt;inputoutput: 输出 // 输出//----------------以上为定义参数-------------------------//----------------以下为连接参数-------------------------// 开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;ec1(no)-&gt;e // 条件1不满足-&gt;结束c2(no)-&gt;e // 条件2不满足-&gt;结束c3(no)-&gt;e // 条件3不满足-&gt;结束 21.参考地址Markdown语法整理大集合","categories":[{"name":"note","slug":"note","permalink":"http://WangGenzhen.github.io/categories/note/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://WangGenzhen.github.io/tags/markdown/"}]},{"title":"jQuery技术内幕","slug":"jQuery技术内幕","date":"2018-08-19T15:05:41.000Z","updated":"2018-08-20T06:02:50.000Z","comments":true,"path":"2018/08/19/jQuery技术内幕/","link":"","permalink":"http://WangGenzhen.github.io/2018/08/19/jQuery技术内幕/","excerpt":"jQuery技术内幕：","text":"jQuery技术内幕： jQuery的无new操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061(function (window, undefined) &#123; /* undefined = 42; alert(undefined);//42 在函数内部就是变量，可以被赋值，在外部就是关键字，不可以不赋值 */ /* //new的话，s就能访问jq原型链的所有方法 //不new的话，q也就能访问jq原型链的所有方法-&gt;value var s = new $(&apos;.test&apos;); var q = $(&apos;.test&apos;); //为什么呢？ //new jQuery -&gt;1构造函数 2prototype的方法 //new 第一步 返回一个init函数 原型链上挂载了一个init函数 没有主动的执行 //init没调用 被搁置了 //构造函数内部的 return new生效了 //jQuery.prototype */ var jQuery = function(selector,context)&#123; //默默的做了一个new, 实际上就是new的原型jQuery.prototype return new jQuery.fn.init(selector,context); &#125;; jQuery.fn = jQuery.prototype = &#123; init:function(selector,context)&#123; &#125; &#125;; jQuery.fn.init.prototype = jQuery.fn; &#125;)(window); //为什么绕一圈来new自己，而不是直接new自己？ 为了得到jQuery原型链上的方法，暴露出去一个fn，fn上拥有jQuery原型链上所有的方法 //$.fn //jQuery.fn.extend，给jQuery对象添加方法。直接挂载到了jQuery原型链上 //jQuery.extend，为扩展jQuery类本身.为类添加新的方法。 直接挂载到了jQuery对象身上 /* //一般写插件 jQuery.fn.extend(&#123; a:function()&#123; console.log(123); &#125; &#125;); $(&apos;&apos;).a(); */ /* //为jQuery类添加类方法，可以理解为添加静态方法。 jQuery.extend(&#123; a:function()&#123; console.log(13); &#125; &#125;); $.a;//13 */ /* undefined = 42; alert(undefined);//undefined 在外边是关键字 */ jQuery的链式调用如何实现的123456789101112131415161718192021222324252627282930/* //链式调用如何实现的 var s = &#123; a:function()&#123; console.log(&apos;first&apos;) &#125;, b:function()&#123; console.log(&apos;second&apos;) &#125;, c:function()&#123; console.log(&apos;three&apos;) &#125; &#125;; s.a().b().c();//first 报错 var s = &#123; a:function()&#123; console.log(&apos;first&apos;); return this//把指针return回去 &#125;, b:function()&#123; console.log(&apos;second&apos;); return this &#125;, c:function()&#123; console.log(&apos;three&apos;); return this &#125; &#125;; s.a().b().c();//first second three */ 实现函数的重载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//jQuery的一个用法，$()，括号中可以接受不同的值，实际上就引出了一个概念，函数的重载$(&apos;.test&apos;).val();//取值 赋值 //$(&apos;.test&apos;,&quot;td&quot;) //$([&apos;.test&apos;,&quot;td&quot;]) //$(function()&#123;&#125;) //$()-&gt;函数 函数的重载函数的重载：同一个函数接受不同的参数处理不同的事情 如何实现： 思路一：通过arguments.length进行判断，因为参数不知道会有多少个，每个都需要判断，穷举法不行 思路二：利用闭包可以保存变量的特性, // old undefined obj.find-&gt;find0 // old find0 obj.find-&gt;find1 // old find1 obj.find-&gt;find2 function addMethod(obj,name,f)&#123; console.log(f);//find0() find1() console.log(f.length);//0//1//函数的参数长度 console.log(arguments.length);//3//3 var old = obj[name];//第一次undefined obj[name] = function()&#123;//如果f的形参等于实参，则说明找到了合适的处理 if(f.length === arguments.length)&#123; //this等于obj return f.apply(this,arguments) &#125;else&#123;//如果f的形参不等于实参，则说明没有找到合适的处理，则会继续找 return old.apply(this,arguments) &#125; &#125; &#125; var people = &#123; name:[&apos;张三&apos;,&apos;李四&apos;,&apos;王&apos;,&apos;高&apos;] &#125;; var find0 = function()&#123; return this.name; &#125;; var find1 = function(name)&#123; var arr = this.name; for(var i = 0;i&lt;=arr.length;i++ )&#123; if(arr[i] == name)&#123; return arr[i]+&quot;在&quot;+i+&quot;位&quot;; &#125; &#125; &#125;;var find2 = function(name,age)&#123;\\console.log(&quot;naemage&quot;)&#125; addMethod(people,&apos;find&apos;,find0); addMethod(people,&apos;find&apos;,find1); addMethod(people,&apos;find&apos;,find2); // console.log(people.find());//(3) [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;] console.log(people.find(&quot;李四&quot;));//李四在1位 console.log(people.find(&quot;&quot;,&quot;&quot;));// 短路表达式1234567891011121314 /* var a ; if(a)&#123; foo = a; &#125;else &#123; foo = b; &#125; var foo = a||b;//第一个为真就输出第一个，第一个为假第二个为真就输出第二个，第一个为假第二个为假就输出第二个 var foo = a&amp;&amp;b;//第一个为真，第二个为真输出第二个，第一个为假输出第一个*/ 执行顺序是从右往左示例：var a=1,b=2,c=0;a&amp;&amp;b&amp;&amp;c //0实际执行顺序是：a&amp;&amp;(b&amp;&amp;c) 钩子机制12345678var data = &#123; index1:1, index2:2 &#125;var s = &quot;index1&quot;;data[s]&amp;&amp;data[s]();//如果有就执行函数//之前的话需要用if,else进行判断 jQuery ready的实现123456789101112131415jQuery的ready方法实现了当页面加载完成后才执行的效果，但它并不是window.onload或者document.onload的封装，而是使用标准w3c浏览器dom隐藏api和ie浏览器缺陷来完成的。代码如下：DOMContentLoaded = function()&#123; if(document.addEventListener)&#123; //取消事件监听，执行ready方法 document.removeEventListener(&quot;DOMContentLoaded&quot;,DOMContentLoaded,false); jQuery.ready(); &#125;else if(document.readyState === &quot;complete&quot;)&#123; //取消事件监听，执行ready方法 document.detachEvent(&quot;onreadystatechange&quot;,DOMContentLoaded); jQuery.ready(); &#125;&#125;jQuery.ready.promise = function(obj)&#123; readyList = jQuery.deferred();&#125;","categories":[{"name":"note","slug":"note","permalink":"http://WangGenzhen.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://WangGenzhen.github.io/tags/jQuery/"}]},{"title":"ES5核心技巧","slug":"ES5核心技巧","date":"2018-08-14T15:05:41.000Z","updated":"2018-08-20T05:25:56.000Z","comments":true,"path":"2018/08/14/ES5核心技巧/","link":"","permalink":"http://WangGenzhen.github.io/2018/08/14/ES5核心技巧/","excerpt":"ES5核心技巧：","text":"ES5核心技巧： 变量提升123456(function()&#123;alert(a); //function a()&#123;&#125;var a = 1;//a的赋值要保存当前的词法作用域function a()&#123;&#125;&#125;)() 等价于123456(function()&#123;function a()&#123;&#125;var a;//发现没有值就直接被忽略了alert(a);//function a()&#123;&#125;a = 1;&#125;)() ES6里边的let作用域如何实现 try catch 实现 12345try&#123; throw 1;&#125;catch(a)&#123; alert(a);&#125; with 实现（但是有问题） *会延长作用域链 1234567var s = &#123; a:1&#125;with(s)&#123; b = 2;//lbs 没有b就会在全局创建一个b，只对已存在的属性赋值&#125;alert(s.b)//undefined 回收问题123456789functon test()&#123; var a = 1; return function ()&#123; eval(&quot;&quot;);//加了这个a不会被回收，因为不确定会不会用到a //with,try catch也不会回收 //不加这三个，a就会被回收&#125;&#125; test(); this问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394this.a = 20;var s = &#123; a:30; init:function()&#123; alert(a); &#125;&#125; s.init();//30 s调用的var s = s.init; s();//20 ---------------------------------------------------------this.a = 20;var s = &#123; a:30, init:()=&gt;&#123; alert(this.a);//箭头函数改变了this的指向,总是指向词法作用域，也就是最外层的obj &#125;&#125; s.init();//20------------------------------------------------------------this.a = 20;var s = &#123; a:30, b:&#123; a:30, fn:()=&gt;&#123; alert(&quot;fn&quot;+this.a); &#125;&#125;,init:()=&gt;&#123; alert(this.a);//箭头函数改变了this,找到父级最外边的作用域 &#125;&#125; s.init();//20s.b.fn();//20--------------------------------------------------------------function test()&#123; this.a = 20;&#125;test.prototype.a = 30;console.log((new test()).a)//20;原型链的优先级低于构造函数的优先级---------------------------------------------------------class test&#123; a()&#123; console.log(1) &#125;&#125;test.prototype.a = function()&#123;console.log(2)&#125;console.log((new test).a());//2 之所以会输出2是因为整个类的实现是基于js的原型链实现的----------class是基于原型链实现的过程，上面的代码就等价与下面的代码---------function test()&#123;&#125;test.prototype.a = function()&#123; console.log(1)&#125;test.prototype.a = function()&#123; console.log(2)&#125;console.log((new test).a());//2 -----------------------------------------------------------------------class基于原型链实现原理class test&#123; constructor()&#123; this.a = function()&#123; console.log(0); &#125;;&#125;a()&#123; console.log(1)&#125;&#125;test.prototype.a = function()&#123;console.log(2)&#125;console.log((new test).a());//0 整个类是基于es的原型链实现的------------上面的代码等价于下面的代码------------function test()&#123; //test.constructor = test; this.a = function ()&#123; console.log(0) &#125;;&#125;test.prototype.a = function()&#123; console.log(1)&#125;test.prototype.a = function()&#123; console.log(2)&#125;console.log((new test).a());//0 暂时性死区1234567//还没定义就使用var i;if(true)&#123; i = 5; let i;&#125;alert(i);/ 报错，i is not defined 同步队列和异步队列，微任务和宏任务js执行会生成一个同步队列和一个异步队列 异步队列包含（绑定的事件，ajax，延时），异步队列又分宏任务和微任务，浏览器加载的时候当同步队列的执行完毕之后会去异步队列取值 按值传递和按引用传递 函数的参数如果是原始类型的值，传递方式是按值传递，这意味着在函数体内修改参数的值，不会影响到函数外部 函数的参数如果是符合类型的值，传递方式是按引用传递，也就是传入函数的是原始值的地址，因此在函数内部修改参数，将会影响到原始值。12345678function s(m)&#123; m.v = 5;//这个m和外边的m是不是一个m，只是指向同一个地址,可以这样写function s(a)&#123;a.v = 5&#125;,不会影响结果 //如果被重写了 m = &#123;k:1&#125;; 这样就会弹出undefined，因为指向了新的地址&#125;var m = &#123;a:1&#125;s(m);alert(m.v)//5 巧妙使用js写法一句话写出0-100学生的等级1234var s=70;(function a(c,n)&#123; s&gt;=c?console.log(n):a(c-10,++n);&#125;)(90,1); 用一句话遍历变量a,a=’abc’ 1.对ES6的理解，Array.from(a); 2.对ES5的灵活运用，Array.prototype.slice(a); 3.a.split(“”); 原型链","categories":[{"name":"note","slug":"note","permalink":"http://WangGenzhen.github.io/categories/note/"}],"tags":[{"name":"ES5","slug":"ES5","permalink":"http://WangGenzhen.github.io/tags/ES5/"}]},{"title":"github和hexo一步步搭建自己的博客","slug":"github一步步搭建自己的博客","date":"2018-08-14T02:35:37.000Z","updated":"2018-08-20T05:25:56.000Z","comments":true,"path":"2018/08/14/github一步步搭建自己的博客/","link":"","permalink":"http://WangGenzhen.github.io/2018/08/14/github一步步搭建自己的博客/","excerpt":"github和hexo一步步搭建自己的博客： 博客搭建","text":"github和hexo一步步搭建自己的博客： 博客搭建 前言使用github pages服务搭建博客的好处： 1.全是静态文件，访问速度快；2.免费方便，不需要服务器不需要后天；3.可以随意绑定自己的域名；4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5.博客内容可以轻松打包、转移、发布发布到其它平台。6.…… 准备工作在开始一切之前，你必须已经： 有一个github账号 安装了node、npm,并了解相关知识 安装了git搭建github博客创建仓库新建一个名为你的用户名.github.io的仓库，比如你的github用户名是user,那么新建的仓库名就是user.github.io（必须是你的用户名，否则无效），将来你的网站就可以通过http://user.github.iof访问了。 绑定域名不绑定域名也是也是可以的，可以用默认的username.github.io来访问，如果想要拥有一个自己的域名也是可以的。首先需要你注册一个域名，阿里云什么的都可以，价格也不贵。域名配置最常见的有两种方式，CNAME和A记录，CNAME和A记录填写IP,IP可以通过ping一下你的用户名.github.io的IP。然后到你的github项目根目录下新建一个CNAME的文件，里面填写你的域名。配置SSH Key为什么要配置这个，因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了。所以使用ssh key来解决本地和服务器连接问题。在终端中执行以下命令：cd ~/.ssh如果提示：no such file or directory说明你是第一次使用git。需要执行下面的命令：ssh-keygen -t rsa -C &quot;邮件地址&quot;&quot;然后连续回车三次，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh/id_rsa.pub文件，记事本打开复制里面的内容，打开你的github主页，进入个人设置：SSH and GPG keys-&gt;New SSH key将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否成功ssh -T git@github.com如果提示Are you sure you want to continue connecting(yes/no),输入yes,然后会看到： Hi username! You’ve successfully authnenticated,but Github does not provid shell access.看到这个信息，说明SSH已配置成功。 使用hexo博客简介hexo是一个简单、快速、强大的基于Github Pages的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 安装npm install hexo -g 初始化在电脑的某个地方新建一个为名blog的文件夹（名字随意取） 1234cd blog的路径hexo inithexo g #生成hexo s #启动服务 执行以上命令后，hexo就会在public文件夹生成相关html的文件，这些文件将来是要提交到github上去的。这是访问http://localhost:4000就可以看到内容了。 修改主题默认的主题很丑，我们可以自己选一个好看的，我选的是balck-blue首先下载这个主题：12cd blog路径git https://github.com/WangGenzhen/black-blue.git themes/black-blue 修改_config.yml中的theme:landscape改为theme:black-blue,重新执行hexo g来重新生成。 上传到github如果一切都配置好了，一句hexo d 就可以。 首先SSH key要配好 其次,配置_config.yml中有关deploy的部分 1234deploy: type: git repository: git@github.com/username/username.github.io.git branch: master 此时如果执行hexo d，一般会报错原因是还需要安装一个插件： npm install hexo-deployer-git --save 安装成功现在访问http://username.github.io，就可以看到搭建好的博客了。 参考地址Hexo和github打造个人博客Hexo自用黑色主题","categories":[{"name":"note","slug":"note","permalink":"http://WangGenzhen.github.io/categories/note/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://WangGenzhen.github.io/tags/博客/"},{"name":"github","slug":"github","permalink":"http://WangGenzhen.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://WangGenzhen.github.io/tags/hexo/"}]}]}